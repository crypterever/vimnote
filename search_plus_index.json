{"./":{"url":"./","title":"简介","keywords":"","body":"My vimnote introductionThis is winnerzr's vimnote.It mainly show you some vim skills,which was learned through studying.Welcome to star and fork.My vimnote introduction This is winnerzr's vimnote. It mainly show you some vim skills,which was learned through studying. Welcome to star and fork. My hexo blog is Winnerzr. My github link Winnerzr. It is a book powered by GitBook. The software used in the experiment is Vim Your support is the driving force of my creation. © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:39:53 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"大神vim.html":{"url":"大神vim.html","title":"大神","keywords":"","body":"Vim 从入门到精通简介什么是 Vim？Vim 哲学入门精简的 vimrcWindows 系统Linux 或者 Mac OS我正在使用什么样的 Vim备忘录基础缓冲区，窗口，标签已激活、已载入、已列出、已命名的缓冲区参数列表按键映射映射前置键寄存器范围标注补全动作，操作符，文本对象自动命令变更历史，跳转历史内容变更历史记录全局位置信息表，局部位置信息表宏颜色主题折叠会话局部化用法获取离线帮助获取离线帮助（补充）获取在线帮助执行自动命令用户自定义事件事件嵌套剪切板剪贴板的使用（Windows, OSX）剪贴板的使用（Linux, BSD, ...）打开文件时恢复光标位置临时文件备份文件交换文件撤销文件viminfo 文件临时文件管理设置示例编辑远程文件插件管理多行编辑使用外部程序和过滤器Cscope1. 构建数据库2. 添加数据库3. 查询数据库MatchIt在 Vim 8 中安装在 Vim 7 或者更早的版本中安装简短的介绍技巧跳至选择的区域另一端聪明地使用 n 和 N聪明地使用命令行历史智能 Ctrl-l禁用错误报警声音和图标快速移动当前行快速添加空行运行时检测查看启动时间NUL 符用新行表示快速编辑自定义宏快速跳转到源(头)文件在 GUI 中快速改变字体大小根据模式改变光标类型防止水平滑动的时候失去选择选择当前行至结尾，排除换行符重新载入保存文件更加智能的当前行高亮更快的关键字补全改变颜色主题的默认外观命令:global 和 :vglobal - 在所有匹配行执行命令:normal 和 :execute - 脚本梦之队重定向消息调试常规建议调整日志等级查看启动日志查看运行时日志Vim 脚本调试语法文件调试杂项附加资源Vim 配置集合常见问题编辑小文件时很慢编辑大文件的时候很慢持续粘贴（为什么我每次都要设置 'paste' 模式）在终端中按 ESC 后有延时无法重复函数中执行的搜索进阶阅读加入我们参考资料 Vim 从入门到精通 English | Japanese | Portuguese | Russian Licensed under CC BY-SA 4.0. 简介 什么是 Vim？ Vim 哲学 入门 精简的 vimrc Windows 系统 Linux 或者 Mac OS 我正在使用什么样的 Vim 备忘录 基础 缓冲区，窗口，标签 已激活、已载入、已列出、已命名的缓冲区 参数列表 按键映射 映射前置键 寄存器 范围 标注 补全 动作，操作符，文本对象 自动命令 变更历史，跳转历史 内容变更历史记录 全局位置信息表，局部位置信息表 宏 颜色主题 折叠 会话 局部化 用法 获取离线帮助 获取离线帮助（补充） 获取在线帮助 执行自动命令 用户自定义事件 事件嵌套 剪切板 剪贴板的使用（Windows, OSX） 剪贴板的使用（Linux, BSD, ...） 打开文件时恢复光标位置 临时文件 备份文件 交换文件 撤销文件 viminfo 文件 临时文件管理设置示例 编辑远程文件 插件管理 多行编辑 使用外部程序和过滤器 Cscope 1. 构建数据库 2. 添加数据库 3. 查询数据库 MatchIt 在 Vim 8 中安装 在 Vim 7 或者更早的版本中安装 简短的介绍 技巧 跳至选择的区域另一端 聪明地使用 n 和 N 聪明地使用命令行历史 智能 Ctrl-l 禁用错误报警声音和图标 快速移动当前行 快速添加空行 运行时检测 查看启动时间 NUL 符用新行表示 快速编辑自定义宏 快速跳转到源(头)文件 在 GUI 中快速改变字体大小 根据模式改变光标类型 防止水平滑动的时候失去选择 选择当前行至结尾，排除换行符 重新载入保存文件 更加智能的当前行高亮 更快的关键字补全 改变颜色主题的默认外观 命令 :global 和 :vglobal - 在所有匹配行执行命令 :normal 和 :execute - 脚本梦之队 重定向消息 调试 常规建议 调整日志等级 查看启动日志 查看运行时日志 Vim 脚本调试 语法文件调试 杂项 附加资源 Vim 配置集合 常见问题 编辑小文件时很慢 编辑大文件的时候很慢 持续粘贴（为什么我每次都要设置 'paste' 模式） 在终端中按 ESC 后有延时 无法重复函数中执行的搜索 进阶阅读 加入我们 参考资料 简介 什么是 Vim？ Vim 是一个历史悠久的文本编辑器，可以追溯到 qed>)。 Bram Moolenaar 于 1991 年发布初始版本。 Linux、Mac 用户，可以使用包管理器安装 Vim，对于 Windows 用户，可以从 我的网盘 下载。 该版本可轻易添加 python 、python3 、lua 等支持，只需要安装 python、lua 即可。 项目在 Github 上开发，项目讨论请订阅 vim_dev 邮件列表。 通过阅读 Why, oh WHY, do those #?@! nutheads use vi? 来对 Vim 进行大致的了解。 Vim 哲学 Vim 采用模式编辑的理念，即它提供了多种模式，按键在不同的模式下作用不同。 你可以在普通模式 下浏览文件，在插入模式下插入文本， 在可视模式下选择行，在命令模式下执行命令等等。起初这听起来可能很复杂， 但是这有一个很大的优点：不需要通过同时按住多个键来完成操作， 大多数时候你只需要依次按下这些按键即可。越常用的操作，所需要的按键数量越少。 和模式编辑紧密相连的概念是 操作符 和 动作。操作符 指的是开始某个行为， 例如：修改、删除或者选择文本，之后你要用一个 动作 来指定需要操作的文本区域。 比如，要改变括号内的文本，需要执行 ci( （读做 change inner parentheses）； 删除整个段落的内容，需要执行 dap （读做：delete around paragraph）。 如果你能看见 Vim 老司机操作，你会发现他们使用 Vim 脚本语言就如同钢琴师弹钢琴一样。复杂的操作只需要几个按键就能完成。他们甚至不用刻意去想，因为这已经成为肌肉记忆了。这减少认识负荷并帮助人们专注于实际任务。 入门 Vim 自带一个交互式的教程，内含你需要了解的最基础的信息，你可以通过终端运行以下命令打开教程： $ vimtutor 不要因为这个看上去很无聊而跳过，按照此教程多练习。你以前用的 IDE 或者其他编辑器很少是有“模式”概念的，因此一开始你会很难适应模式切换。但是你 Vim 使用的越多，肌肉记忆 将越容易形成。 Vim 基于一个 vi 克隆，叫做 Stevie>)，支持两种运行模式：\"compatible\" 和 \"nocompatible\"。在兼容模式下运行 Vim 意味着使用 vi 的默认设置，而不是 Vim 的默认设置。除非你新建一个用户的 vimrc 或者使用 vim -N 命令启动 Vim，否则就是在兼容模式下运行 Vim！请大家不要在兼容模式下运行 Vim。 下一步 创建你自己的 vimrc。 在第一周准备备忘录。 通读基础章节了解 Vim 还有哪些功能。 按需学习！Vim 是学不完的。如果你遇到了问题，先上网寻找解决方案，你的问题可能已经被解决了。Vim 拥有大量的参考文档，知道如何利用这些参考文档很有必要：获取离线帮助。 浏览附加资源。 最后一个建议：使用插件之前，请先掌握 Vim 的基本操作。很多插件都只是对 Vim 自带功能的封装。 返回主目录 :arrow_heading_up: 精简的 vimrc Vim 启动是会按照一定的优先顺序来搜索配置文件，这个顺序，可以通过 :version 命令查看。下面分 Windows 系统， 和 *niux 系统分别来说明 Vim 是如何载入配置文件的。 Windows 系统 system vimrc file: \"$VIM\\vimrc\" user vimrc file: \"$HOME\\_vimrc\" 2nd user vimrc file: \"$HOME\\vimfiles\\vimrc\" 3rd user vimrc file: \"$VIM\\_vimrc\" user exrc file: \"$HOME\\_exrc\" 2nd user exrc file: \"$VIM\\_exrc\" system gvimrc file: \"$VIM\\gvimrc\" user gvimrc file: \"$HOME\\_gvimrc\" 2nd user gvimrc file: \"$HOME\\vimfiles\\gvimrc\" 3rd user gvimrc file: \"$VIM\\_gvimrc\" defaults file: \"$VIMRUNTIME\\defaults.vim\" system menu file: \"$VIMRUNTIME\\menu.vim\" 我们只看上面这一段，Vim 会优先读取 user vimrc file: $HOME\\_vimrc, 当这一文件不存在是， Vim 再去寻找 2nd user vimrc file: $HOME\\vimfiles\\vimrc; 倘若这个文件还是不存在，那么 Vim 会去继续寻找 3rd user vimrc file: $VIM\\_vimrc。 了解以上顺序后，就不会再因为 Vim 总是不读取配置文件而感到烦恼了。 Linux 或者 Mac OS 同 Windows 系统类似，也可以使用 :version 命令查看 vim 载入配置的优先顺序。 系统 vimrc 文件: \"/etc/vimrc\" 用户 vimrc 文件: \"$HOME/.vimrc\" 第二用户 vimrc 文件: \"~/.vim/vimrc\" 用户 exrc 文件: \"$HOME/.exrc\" defaults file: \"$VIMRUNTIME/defaults.vim\" $VIM 预设值: \"/etc\" $VIMRUNTIME 预设值: \"/usr/share/vim/vim81\" 你可以在网上找到许多精简的 vimrc 配置文件，我的版本可能并不是最简单的版本，但是我的版本提供了一套我认为良好的，非常适合入门的设置。 最终你需要阅读完那些设置，然后自行决定需要使用哪些。:-) 精简的 vimrc 地址：minimal-vimrc 如果你有兴趣，这里是我（原作者）的 vimrc。 建议：大多数插件作者都维护不止一个插件并且将他们的 vimrc 放在 Github 上展示（通常放在叫做 \"vim-config\" 或者 \"dotfiles\" 的仓库中），所以当你发现你喜欢的插件时，去插件维护者的 Github 主页看看有没有这样的仓库。 返回主目录 :arrow_heading_up: 我正在使用什么样的 Vim 使用 :version 命令将向你展示当前正在运行的 Vim 的所有相关信息，包括它是如何编译的。 第一行告诉你这个二进制文件的编译时间和版本号，比如：7.4。接下来的一行呈现 Included patches: 1-1051，这是补丁版本包。因此你 Vim 确切的版本号是 7.4.1051。 另一行显示着一些像 Tiny version without GUI 或者 Huge version with GUI 的信息。很显然这些信息告诉你当前的 Vim 是否支持 GUI，例如：从终端中运行 gvim 或者从终端模拟器中的 Vim 内运行 :gui 命令。另一个重要的信息是 Tiny 和 Huge。Vim 的特性集区分被叫做 tiny，small，normal，big and huge，所有的都实现不同的功能子集。 :version 主要的输出内容是特性列表。+clipboard 意味这剪贴板功能被编译支持了，-clipboard 意味着剪贴板特性没有被编译支持。 一些功能特性需要编译支持才能正常工作。例如：为了让 :prof 工作，你需要使用 huge 模式编译的 Vim，因为那种模式启用了 +profile 特性。 如果你的输出情况并不是那样，并且你是从包管理器安装 Vim 的，确保你安装了 vim-x，vim-x11，vim-gtk，vim-gnome 这些包或者相似的，因为这些包通常都是 huge 模式编译的。 你也可以运行下面这段代码来测试 Vim 版本以及功能支持： \" Do something if running at least Vim 7.4.42 with +profile enabled. if (v:version > 704 || v:version == 704 && has('patch42')) && has('profile') \" do stuff endif 相关帮助： :h :version :h feature-list :h +feature-list :h has-patch 返回主目录 :arrow_heading_up: 备忘录 为了避免版权问题，我只贴出链接： http://people.csail.mit.edu/vgod/vim/vim-cheat-sheet-en.png https://cdn.shopify.com/s/files/1/0165/4168/files/preview.png http://www.nathael.org/Data/vi-vim-cheat-sheet.svg http://michael.peopleofhonoronly.com/vim/vim_cheat_sheet_for_programmers_screen.png http://www.rosipov.com/images/posts/vim-movement-commands-cheatsheet.png 或者在 Vim 中快速打开备忘录：vim-cheat40。 返回主目录 :arrow_heading_up: 基础 缓冲区，窗口，标签 Vim 是一个文本编辑器。每次文本都是作为缓冲区的一部分显示的。每一份文件都是在他们自己独有的缓冲区打开的，插件显示的内容也在它们自己的缓冲区中。 缓冲区有很多属性，比如这个缓冲区的内容是否可以修改，或者这个缓冲区是否和文件相关联，是否需要同步保存到磁盘上。 窗口 是缓冲区上一层的视窗。如果你想同时查看几个文件或者查看同一文件的不同位置，那样你会需要窗口。 请别把他们叫做 分屏 。你可以把一个窗口分割成两个，但是这并没有让这两个窗口完全 分离 。 窗口可以水平或者竖直分割并且现有窗口的高度和宽度都是可以被调节设置的，因此，如果你需要多种窗口布局，请考虑使用标签。 标签页 （标签）是窗口的集合。因此当你想使用多种窗口布局时候请使用标签。 简单的说，如果你启动 Vim 的时候没有附带任何参数，你会得到一个包含着一个呈现一个缓冲区的窗口的标签。 顺带提一下，缓冲区列表是全局可见的，你可以在任何标签中访问任何一个缓冲区。 返回主目录 :arrow_heading_up: 已激活、已载入、已列出、已命名的缓冲区 用类似 vim file1 的命令启动 Vim 。这个文件的内容将会被加载到缓冲区中，你现在有一个已载入的缓冲区。如果你在 Vim 中保存这个文件，缓冲区内容将会被同步到磁盘上（写回文件中）。 由于这个缓冲区也在一个窗口上显示，所以他也是一个已激活的缓冲区。如果你现在通过 :e file2 命令加载另一个文件，file1 将会变成一个隐藏的缓冲区，并且 file2 变成已激活缓冲区。 使用 :ls 我们能够列出所有可以列出的缓冲区。插件缓冲区和帮助缓冲区通常被标记为不可以列出的缓冲区，因为那并不是你经常需要在编辑器中编辑的常规文件。通过 :ls! 命令可以显示被放入缓冲区列表的和未被放入列表的缓冲区。 未命名的缓冲区是一种没有关联特定文件的缓冲区，这种缓冲区经常被插件使用。比如 :enew 将会创建一个无名临时缓冲区。添加一些文本然后使用 :w /tmp/foo 将他写入到磁盘，这样这个缓冲区就会变成一个已命名的缓冲区。 返回主目录 :arrow_heading_up: 参数列表 全局缓冲区列表是 Vim 的特性。在这之前的 vi 中，仅仅只有参数列表，参数列表在 Vim 中依旧可以使用。 每一个通过 shell 命令传递给 Vim 的文件名都被记录在一个参数列表中。可以有多个参数列表：默认情况下所有参数都被放在全局参数列表下，但是你可以使用 :arglocal 命令去创建一个新的本地窗口的参数列表。 使用 :args 命令可以列出当前参数。使用 :next，:previous，:first，:last 命令可以在切换在参数列表中的文件。通过使用 :argadd，:argdelete 或者 :args 等命令加上一个文件列表可以改变参数列表。 偏爱缓冲区列表还是参数列表完全是个人选择，我的印象中大多数人都是使用缓冲区列表的。 然而参数列表在有些情况下被大量使用：批处理 使用 :argdo！ 一个简单的重构例子： :args **/*.[ch] :argdo %s/foo/bar/ge | update 这条命令将替换掉当前目录下以及当前目录的子目录中所有的 C 源文件和头文件中的“foo”，并用“bar”代替。 相关帮助：:h argument-list 返回主目录 :arrow_heading_up: 按键映射 使用 :map 命令家族你可以定义属于你自己的快捷键。该家族的每一个命令都限定在特定的模式下。从技术上来说 Vim 自带高达 12 中模式，其中 6 种可以被映射。另外一些命令作用于多种模式： 递归 非递归 模式 :map :noremap normal, visual, operator-pending :nmap :nnoremap normal :xmap :xnoremap visual :cmap :cnoremap command-line :omap :onoremap operator-pending :imap :inoremap insert 例如：这个自定义的快捷键只在普通模式下工作。 :nmap :echo \"foo\" 使用 :nunmap 可以取消这个映射。 对于更少数，不常见的模式（或者他们的组合），查看 :h map-modes。 到现在为止还好，对新手而言有一个问题会困扰他们：:nmap 是递归执行的！结果是，右边执行可能的映射。 你自定义了一个简单的映射去输出“Foo”： :nmap b :echo \"Foo\" 但是如果你想要映射 b （回退一个单词）的默认功能到一个键上呢？ :nmap a b 如果你敲击a，我们期望着光标回退到上一个单词，但是实际情况是“Foo”被输出到命令行里！因为在右边，b 已经被映射到别的行为上了，换句话说就是 :echo \"Foo\"。 解决此问题的正确方法是使用一种 非递归 的映射代替： :nnoremap a b 经验法则：除递归映射是必须的，否则总是使用非递归映射。 通过不给一个右值来检查你的映射。比如:nmap 显示所以普通模式下的映射，:nmap 显示所有以 键开头的普通模式下的映射。 如果你想禁止用标准映射，把他们映射到特殊字符 上，例如：:noremap 。 相关帮助： :h key-notation :h mapping :h 05.3 返回主目录 :arrow_heading_up: 映射前置键 映射前置键（Leader 键）本身就是一个按键映射，默认为 \\。我们可以通过在 map 中调用 来为把它添加到其他按键映射中。 nnoremap h :helpgrep 这样，我们只需要先按 \\ 然后按 h 就可以激活这个映射 :helpgrep。如果你想通过先按 空格 键来触发，只需要这样做： let g:mapleader = ' ' nnoremap h :helpgrep 此处建议使用 g:mapleader，因为在 Vim 脚本中，函数外的变量缺省的作用域是全局变量，但是在函数内缺省作用域是局部变量，而设置快捷键前缀需要修改全局变量 g:mapleader 的值。 另外，还有一个叫 的，可以把它理解为局部环境中的 ，默认值依然为 \\。当我们需要只对某一个条件下（比如，特定文件类型的插件）的缓冲区设置特别的 键，那么我们就可以通过修改当前环境下的 来实现。 注意：如果你打算设置 Leader 键，请确保在设置按键映射之前，先设置好 Leader 键。如果你先设置了含有 Leader 键的映射，然后又修改了 Leader 键，那么之前映射内的 Leader 键是不会因此而改变的。你可以通过执行 :nmap 来查看普通模式中已绑定给 Leader 键的所有映射。 请参阅 :h mapleader 与 :h maploacalleader 来获取更多帮助。 返回主目录 :arrow_heading_up: 寄存器 寄存器就是存储文本的地方。我们常用的「复制」操作就是把文本存储到寄存器，「 粘贴」 操作就是把文本从寄存器中读出来。顺便，在 Vim 中复制的快捷键是 y，粘贴的快捷键是 p。 Vim 为我们提供了如下的寄存器： 类型 标识 读写者 是否为只读 包含的字符来源 Unnamed \" vim 否 最近一次的复制或删除操作 (d, c, s, x, y) Numbered 0至9 vim 否 寄存器 0: 最近一次复制。寄存器 1: 最近一次删除。寄存器 2: 倒数第二次删除，以此类推。对于寄存器 1 至 9，他们其实是只读的最多包含 9 个元素的队列。这里的队列即为数据类型 queue>) Small delete - vim 否 最近一次行内删除 Named a至z, A至Z 用户 否 如果你通过复制操作存储文本至寄存器 a，那么 a 中的文本就会被完全覆盖。如果你存储至 A，那么会将文本添加给寄存器 a，不会覆盖之前已有的文本 Read-only :与.和% vim 是 :: 最近一次使用的命令，.: 最近一次添加的文本，%: 当前的文件名 Alternate buffer # vim 否 大部分情况下，这个寄存器是当前窗口中，上一次访问的缓冲区。请参阅 :h alternate-file 来获取更多帮助 Expression = 用户 否 复制 VimL 代码时，这个寄存器用于存储代码片段的执行结果。比如，在插入模式下复制 =5+5，那么这个寄存器就会存入 10 Selection +和* vim 否 * 和 + 是 剪贴板 寄存器 Drop ~ vim 是 最后一次拖拽添加至 Vim 的文本（需要 \"+dnd\" 支持，暂时只支持 GTK GUI。请参阅 :help dnd 及 :help quote~） Black hole _ vim 否 一般称为黑洞寄存器。对于当前操作，如果你不希望在其他寄存器中保留文本，那就在命令前加上 _。比如，\"_dd 命令不会将文本放到寄存器 \"、1、+ 或 * 中 Last search pattern / vim 否 最近一次通过 /、? 或 :global 等命令调用的匹配条件 只要不是只读的寄存器，用户都有权限修改它的内容，比如： :let @/ = 'register' 这样，我们按 n 的时候就会跳转到单词\"register\" 出现的地方。 有些时候，你的操作可能已经修改了寄存器，而你没有察觉到。请参阅 :h registers 获取更多帮助。 上面提到过，复制的命令是 y，粘贴的命令是 p 或者 P。但请注意，Vim 会区分「字符选取」与「行选取」。请参阅 :h linewise 获取更多帮助。 行选取： 命令 yy 或 Y 都是复制当前行。这时移动光标至其他位置，按下 p 就可以在光标下方粘贴复制的行，按下 P 就可以在光标上方粘贴至复制的行。 字符选取： 命令 0yw 可以复制第一个单词。这时移动光标至其他位置，按下 p 就可以在当前行、光标后的位置粘贴单词，按下 P 就可以在当前行、光标前的位置粘贴单词。 将文本存到指定的寄存器中： 命令 \"aY 可以将当前行复制，并存储到寄存器 a 中。这时移动光标至其他位置，通过命令 \"AY 就可以把这一行的内容扩展到寄存器 a 中，而之前存储的内容也不会丢失。 为了便于理解和记忆，建议大家现在就试一试上面提到的这些操作。操作过程中，你可以随时通过 :reg 来查看寄存器的变化。 有趣的是： 在 Vim 中，y 是复制命令，源于单词 \"yanking\"。而在 Emacs 中，\"yanking\" 代表的是粘贴（或者说，重新插入刚才删掉的内容），而并不是复制。 返回主目录 :arrow_heading_up: 范围 范围 (Ranges) 其实很好理解，但很多 Vim 用户的理解不到位。 很多命令都可以加一个数字，用于指明操作范围 范围可以是一个行号，用于指定某一行 范围也可以是一对通过 , 或 ; 分割的行号 大部分命令，默认只作用于当前行 只有 :write 和 :global 是默认作用于所有行的 范围的使用是十分直观的。以下为一些例子（其中，:d 为 :delete 的缩写）： 命令 操作的行 :d 当前行 :.d 当前行 :1d 第一行 :$d 最后一行 :1,$d 所有行 :%d 所有行（这是 1,$ 的语法糖） :.,5d 当前行至第 5 行 :,5d 同样是当前行至第 5 行 :,+3d 当前行及接下来的 3 行 :1,+3d 第一行至当前行再加 3 行 :,-3d 当前行及向上的 3 行（Vim 会弹出提示信息，因为这是一个保留的范围） :3,'xdelete 第三行至标注 为 x 的那一行 :/^foo/,$delete 当前行以下，以字符 \"foo\" 开头的那一行至结尾 :/^foo/+1,$delete 当前行以下，以字符 \"foo\" 开头的那一行的下一行至结尾 需要注意的是，; 也可以用于表示范围。区别在于，a,b 的 b 是以当前行作为参考的。而 a;b 的 b 是以 a 行作为参考的。举个例子，现在你的光标在第 5 行。这时 :1,+1d 会删除第 1 行至第 6 行，而 :1;+1d 会删除第 1 行和第 2 行。 如果你想设置多个寻找条件，只需要在条件前加上 /，比如： :/foo//bar//quux/d 这就会删除当前行之后的某一行。定位方式是，先在当前行之后寻找第一个包含 \"foo\" 字符的那一行，然后在找到的这一行之后寻找第一个包含 \"bar\" 字符的那一行，然后再在找到的这一行之后寻找第一个包含 \"quux\" 的那一行。删除的就是最后找到的这一行。 有时，Vim 会在命令前自动添加范围。举个例子，如果你先通过 V 命令进入行选取模式，选中一些行后按下 : 进入命令模式，这时候你会发现 Vim 自动添加了 ' 范围。这表示，接下来的命令会使用之前选取的行号作为范围。但如果后续命令不支持范围，Vim 就会报错。为了避免这样的情况发生，有些人会设置这样的按键映射：:vnoremap foo :command，组合键 Ctrl + u 可以清除当前命令行中的内容。 另一个例子是在普通模式中按下 !!，命令行中会出现 :.!。如果这时你如果输入一个外部命令，那么当前行的内容就会被这个外部命令的输出替换。你也可以通过命令 :?^$?+1,/^$/-1!ls 把当前段落的内容替换成外部命令 ls 的输出，原理是向前和向后各搜索一个空白行，删除这两个空白行之间的内容，并将外部命令 ls 的输出放到这两个空白行之间。 请参阅以下两个命令来获取更多帮助： :h cmdline-ranges :h 10.3 返回主目录 :arrow_heading_up: 标注 你可以使用标注功能来标记一个位置，也就是记录文件某行的某个位置。 标注 设置者 使用 a-z 用户 仅对当前的一个文件生效，也就意味着只可以在当前文件中跳转 A-Z 用户 全局标注，可以作用于不同文件。大写标注也称为「文件标注」。跳转时有可能会切换到另一个缓冲区 0-9 viminfo 0 代表 viminfo 最后一次被写入的位置。实际使用中，就代表 Vim 进程最后一次结束的位置。1 代表 Vim 进程倒数第二次结束的位置，以此类推 如果想跳转到指定的标注，你可以先按下 ' / g' 或者 ` / g` 然后按下标注名。 如果你想定义当前文件中的标注，可以先按下 m 再按下标注名。比如，按下 mm 就可以把当前位置标注为 m。在这之后，如果你的光标切换到了文件的其他位置，只需要通过 'm 或者 `m即可回到刚才标注的行。区别在于，'m会跳转回被标记行的第一个非空字符，而`m会跳转回被标记行的被标记列。根据 viminfo 的设置，你可以在退出 Vim 的时候保留小写字符标注。请参阅:h viminfo-' 来获取更多帮助。 如果你想定义全局的标注，可以先按下 m 再按下大写英文字符。比如，按下 mM 就可以把当前文件的当前位置标注为 M。在这之后，就算你切换到其他的缓冲区，依然可以通过 'M 或 `M 跳转回来。 关于跳转，还有以下的方式： 按键 跳转至 '[ 与 `[ 上一次修改或复制的第一行或第一个字符 '] 与 `] 上一次修改或复制的最后一行或最后一个字符 ' 与 ` 上一次在可视模式下选取的第一行或第一个字符 '> 与 `> 上一次在可视模式下选取的最后一行或最后一个字符 '' 与 `' 上一次跳转之前的光标位置 '\" 与 `\" 上一次关闭当前缓冲区时的光标位置 '^ 与 `^ 上一次插入字符后的光标位置 '. 与 `. 上一次修改文本后的光标位置 '( 与 `( 当前句子的开头 ') 与 `) 当前句子的结尾 '{ 与 `{ 当前段落的开头 '} 与 `} 当前段落的结尾 标注也可以搭配 范围 一起使用。前面提到过，如果你在可视模式下选取一些文本，然后按下 :，这时候你会发现命令行已经被填充了 :'。对照上面的表格，现在你应该明白了，这段代表的就是可视模式下选取的范围。 请使用 :marks 命令来显示所有的标注，参阅 :h mark-motions 来获取关于标注的更多帮助。 返回主目录 :arrow_heading_up: 补全 Vim 在插入模式中为我们提供了多种补全方案。如果有多个补全结果，Vim 会弹出一个菜单供你选择。 常见的补全有标签、项目中引入的模块或库中的方法名、文件名、字典及当前缓冲区的字段。 针对不同的补全方案，Vim 为我们提供了不同的按键映射。这些映射都是在插入模式中通过 Ctrl + x 来触发： 映射 类型 帮助文档 整行 :h i^x^l 当前缓冲区中的关键字 :h i^x^n 字典（请参阅 :h 'dictionary'）中的关键字 :h i^x^k 同义词字典（请参阅 :h 'thesaurus'）中的关键字 :h i^x^t 当前文件以及包含的文件中的关键字 :h i^x^i 标签 :h i^x^] 文件名 :h i^x^f 定义或宏定义 :h i^x^d Vim 命令 :h i^x^v 用户自定义补全（通过 'completefunc' 定义） :h i^x^u Omni Completion（通过 'omnifunc' 定义） :h i^x^o s 拼写建议 :h i^Xs 尽管用户自定义补全与 Omni Completion 是不同的，但他们做的事情基本一致。共同点在于，他们都是一个监听当前光标位置的函数，返回值为一系列的补全建议。用户自定义补全是由用户定义的，基于用户的个人用途，因此你可以根据自己的喜好和需求随意定制。而 Omni Completion 是针对文件类型的补全，比如在 C 语言中补全一个结构体（struct）的成员（members），或者补全一个类的方法，因而它通常都是由文件类型插件设置和调用的。 如果你设置了 'complete' 选项，那么你就可以在一次操作中采用多种补全方案。这个选项默认包含了多种可能性，因此请按照自己的需求来配置。你可以通过 来调用下一个补全建议，或通过 来调用上一个补全建议。当然，这两个映射同样可以直接调用补全函数。请参阅 :h i^n 与 :h 'complete' 来获得更多帮助。 如果你想配置弹出菜单的行为，请一定要看一看 :h 'completeopt' 这篇帮助文档。默认的配置已经不错了，但我个人（原作者）更倾向于把 \"noselect\" 加上。 请参阅以下文档获取更多帮助： :h ins-completion :h popupmenu-keys :h new-omni-completion 返回主目录 :arrow_heading_up: 动作，操作符，文本对象 动作也就是指移动光标的操作，你肯定很熟悉 h、j、k 和 l，以及 w 和 b。但其实，/ 也是一个动作。他们都可以搭配数字使用，比如 2?the 可以将光标移动到倒数第二个 \"the\" 出现的位置。 以下会列出一些常用的动作。你也可以通过 :h navigation 来获取更多的帮助。 操作符是对某个区域文本执行的操作。比如，d、~、gU 和 > 都是操作符。这些操作符既可以在普通模式下使用，也可以在可视模式下使用。在普通模式中，顺序是先按操作符，再按动作指令，比如 >j。在可视模式中，选中区域后直接按操作符就可以，比如 Vjd。 与动作一样，操作符也可以搭配数字使用，比如 2gUw 可以将当前单词以及下一个单词转成大写。由于动作和操作符都可以搭配数字使用，因此 2gU2w 与执行两次 gU2w 效果是相同的。 请参阅 :h operator 来查看所有的操作符。你也可以通过 :set tildeop 命令把 ~ 也变成一个操作符 值得注意的是，动作是单向的，而文本对象是双向的。文本对象不仅作用于符号（比如括号、中括号和大括号等）标记的范围内，也作用于整个单词、整个句子等其他情况。 文本对象不能用于普通模式中移动光标的操作，因为光标还没有智能到可以向两个方向同时跳转。但这个功能可以在可视模式中实现，因为在对象的一端选中的情况下，光标只需要跳转到另一端就可以了。 文本对象操作一般用 i 或 a 加上对象标识符操作，其中 i 表示在对象内（英文 inner）操作，a 表示对整个对象（英文 around）操作，这时开头和结尾的空格都会被考虑进来。举个例子，diw 可以删除当前单词，ci( 可以改变括号中的内容。 文本对象同样可以与数字搭配使用。比如，像 ((( ))) 这样的文本，假如光标位于最内层的括号上或最内层的括号内，那么 d2a( 将会删除从最内层开始的两对括号，以及他们之间的所有内容。其实，d2a( 这个操作等同于 2da(。在 Vim 的命令中，如果有两处都可以接收数字作为参数，那么最终结果就等同于两个数字相乘。在这里，d 与 a( 都是可以接收参数的，一个参数是 1，另一个是 2，我们可以把它们相乘然后放到最前面。 请参阅 :h text-objects 来获取更多关于文本对象的帮助。 返回主目录 :arrow_heading_up: 自动命令 在特定的情况下，Vim 会传出事件。如果你想针对这些事件执行回调方法，那么就需要用到自动命令这个功能。 如果没有了自动命令，那你基本上是用不了 Vim 的。自动命令一直都在执行，只是很多时候你没有注意到。不信的话，可以执行命令 :au ，不要被结果吓到，这些是当前有效的所有自动命令。 请使用 :h {event} 来查看 Vim 中所有事件的列表，你也可以参考 :h autocmd-events-abc 来获取关于事件的更多帮助。 一个很常用的例子，就是针对文件类型执行某些设置： autocmd FileType ruby setlocal shiftwidth=2 softtabstop=2 comments-=:# 但是缓冲区是如何知道当前的文件中包含 Ruby 代码呢？这其实是另一个自动命令检测的到的，然后把文件类型设置成为 Ruby，这样就触发了上面的 FileType 事件。 在配置 vimrc 的时候，一般第一行加进去的就是 filetype on。这就意味着，Vim 启动时会读取 filetype.vim 文件，然后根据文件类型来触发相应的自动命令。 如果你勇于尝试，可以查看下 :e $VIMRUNTIME/filetype.vim，然后在输出中搜索 \"Ruby\"。这样，你就会发现其实 Vim 只是通过文件扩展名 .rb 判断某个文件是不是 Ruby 的。 注意：对于相同事件，如果有多个自动命令，那么自动命令会按照定义时的顺序执行。通过 :au 就可以查看它们的执行顺序。 au BufNewFile,BufRead *.rb,*.rbw setf ruby BufNewFile 与 BufRead 事件是被写在 Vim 源文件中的。因此，每当你通过 :e 或者类似的命令打开文件，这两个事件都会触发。然后，就是读取 filetype.vim 文件来判断打开的文件类型。 简单来说，事件和自动命令在 Vim 中的应用十分广泛。而且，Vim 为我们留出了一些易用的接口，方便用户配置适合自己的事件驱动回调。 请参阅 :h autocommand 来获取更多帮助 返回主目录 :arrow_heading_up: 变更历史，跳转历史 在 Vim 中，用户最近 100 次的文字改动都会被保存在变更历史中。如果在同一行有多个小改动，那么 Vim 会把它们合并成一个。尽管内容改动会合并，但作用的位置还是会只记录下最后一次改动的位置。 在你移动光标或跳转的时候，每一次的移动或跳转前的位置会被记录到跳转历史中。类似地，跳转历史也可以最多保存 100 条记录。对于每个窗口，跳转记录是独立的。但当你分离窗口时（比如使用 :split 命令），跳转历史会被复制过去。 Vim 中的跳转命令，包括 '、` 、G、/、?、n、N、%、(、)、[[、]]、{、}、:s、:tag、L、M、H 以及开始编辑一个新文件的命令。 列表 显示所有条目 跳转到上一个位置 跳转到下一个位置 跳转历史 :jumps [count] [count] 变更历史 :changes [count]g; [count]g, 如果你执行第二列的命令显示所有条目，这时 Vim 会用 > 标记来为你指示当前位置。通常这个标记位于 1 的下方，也就代表最后一次的位置。 如果你希望关闭 Vim 之后还保留这些条目，请参阅 :h viminfo-' 来获取更多帮助。 注意：上面提到过，最后一次跳转前的位置也会记录在标注中，也可以通过连按 `` 或 '' 跳转到那个位置 请参阅以下两个命令来获取更多帮助： :h changelist :h jumplist 返回主目录 :arrow_heading_up: 内容变更历史记录 Vim 会记录文本改变之前的状态。因此，你可以使用「撤销」操作 u 来取消更改，也可以通过「重做」操作 Ctrl + r 来恢复更改。 值得注意的是，Vim 采用 tree>) 数据结构来存储内容变更的历史记录，而不是采用 queue>)。你的每次改动都会成为存储为树的节点。而且，除了第一次改动（根节点），之后的每次改动都可以找到一个对应的父节点。每一个节点都会记录改动的内容和时间。其中，「分支」代表从任一节点到根节点的路径。当你进行了撤销操作，然后又输入了新的内容，这时候就相当于创建了分支。这个原理和 git 中的 branch（分支）十分类似。 考虑以下这一系列按键操作： ifoo obar obaz u oquux 那么现在，Vim 中会显示三行文本，分别是 \"foo\"、\"bar\" 和 \"quux\"。这时候，存储的树形结构如下： foo(1) / bar(2) / \\ baz(3) quux(4) 这个树形结构共包含四次改动，括号中的数字就代表时间顺序。 现在，我们有两种方式遍历这个树结构。一种叫「按分支遍历」，一种叫「按时间遍历」。 撤销 u 与重做 Ctrl + r 操作是按分支遍历。对于上面的例子，现在我们有三行字符。这时候按 u 会回退到 \"bar\" 节点，如果再按一次 u 则会回退到 \"foo\" 节点。这时，如果我们按下 Ctrl + r 就会前进至 \"bar\" 节点，再按一次就回前进至 \"quux\" 节点。在这种方式下，我们无法访问到兄弟节点（即 \"baz\" 节点）。 与之对应的是按时间遍历，对应的按键是 g- 和 g+。对于上面的例子，按下 g- 会首先回退到 \"baz\" 节点。再次按下 g- 会回退到 \"bar\" 节点。 命令/按键 执行效果 [count]u 或 :undo [count] 回退到 [count] 次改动之前 [count] 或 :redo [count] 重做 [count] 次改动 U 回退至最新的改动 [count]g- 或 :earlier [count]? 根据时间回退到 [count] 次改动之前。\"?\" 为 \"s\"、\"m\"、\"h\"、\"d\" 或 \"f\"之一。例如，:earlier 2d 会回退到两天之前。:earlier 1f 则会回退到最近一次文件保存时的内容 [count]g+ 或 :later [count]? 类似 g-，但方向相反 内容变更记录会储存在内存中，当 Vim 退出时就会清空。如果需要持久化存储内容变更记录，请参阅备份文件，交换文件，撤销文件以及 viminfo 文件的处理章节的内容。 如果你觉得这一部分的内容难以理解，请参阅 undotree，这是一个可视化管理内容变更历史记录的插件。类似的还有 vim-mundo。 请参阅以下链接获取更多帮助： :h undo.txt :h usr_32 返回主目录 :arrow_heading_up: 全局位置信息表，局部位置信息表 在某一个动作返回一系列「位置」的时候，我们可以利用「全局位置信息表」和「局部位置信息表」来存储这些位置信息，方便以后跳转回对应的位置。每一个存储的位置包括文件名、行号和列号。 比如，编译代码是出现错误，这时候我们就可以把错误的位置直接显示在全局位置信息表，或者通过外部抓取工具使位置显示在局部位置信息表中。 尽管我们也可以把这些信息显示到一个空格缓冲区中，但用这两个信息表显示的好处在于接口调用很方便，而且也便于浏览输出。 Vim 中，全局位置信息表只能有一个，但每一个窗口都可以有自己的局部位置信息表。这两个信息表的外观看上去很类似，但在操作上会稍有不同。 以下为两者的操作比较： 动作 全局位置信息表 局部位置信息表 打开窗口 :copen :lopen 关闭窗口 :cclose :lclose 下一个条目 :cnext :lnext 上一个条目 :cprevious :lprevious 第一个条目 :cfirst :lfirst 最后一个条目 :clast :llast 请参阅 :h :cc 以及底下的内容，来获取更多命令的帮助。 应用实例： 如果我们想用 grep 递归地在当前文件夹中寻找某个关键词，然后把输出结果放到全局位置信息表中，只需要这样： :let &grepprg = 'grep -Rn $* .' :grep! foo :copen 执行了上面的代码，你就能看到所有包含字符串 \"foo\" 的文件名以及匹配到的相关字段都会显示在全局位置信息表中。 返回主目录 :arrow_heading_up: 宏 你可以在 Vim 中录制一系列按键，并把他们存储到寄存器中。对于一些需要临时使用多次的一系列操作，把它们作为宏保存起来会显著地提升效率。对于一些复杂的操作，建议使用 Vim 脚本来实现。 首先，按下 q，然后按下你想要保存的寄存器，任何小写字母都可以。比如我们来把它保存到 q 这个寄存器中。按下 qq，你会发现命令行里已经显示了 \"recording @q\"。 如果你已经录制完成，那么只需要再按一次 q 就可以结束录制。 如果你想调用刚才录制的宏，只需要 [count]@q 如果你想调用上一次使用的宏，只需要 [count]@@ 实例 1： 一个插入字符串 \"abc\" 后换行的宏，重复调用十次： qq iabc q 10@q （对于上面这个功能，你同样可以通过如下的按键： oabc 然后 ESC 然后 10. 来实现）。 实例 2： 一个在每行前都加上行号的宏。从第一行开始，行号为 1，后面依次递增。我们可以通过 Ctrl + a 来实现递增的行号，在定义宏的时候，它会显示成 ^A。 qq 0yf jP0^A q 1000 @q 这里能实现功能，是因为我们假定了文件最多只有 1000 行。但更好的方式是使用「递归」宏，它会一直执行，知道不能执行为止： qq 0yf jP0^A@q q @q （对于上面这个插入行号的功能，如果你不愿意使用宏，同样可以通过这段按键操作来实现：:%s/^/\\=line('.') . '. '）。 这里向大家展示了如何不用宏来达到相应的效果，但要注意，这些不用宏的实现方式只适用于这些简单的示例。对于一些比较复杂的自动化操作，你确实应该考虑使用宏。 请参阅以下文档获取更多帮助： :h recording :h 'lazyredraw' 返回主目录 :arrow_heading_up: 颜色主题 颜色主题可以把你的 Vim 变得更漂亮。Vim 是由多个组件构成的，我们可以给每一个组件都设置不同的文字颜色、背景颜色以及文字加粗等等。比如，我们可以通过这个命令来设置背景颜色： :highlight Normal ctermbg=1 guibg=red 执行后你会发现，现在背景颜色变成红色了。请参阅 :h :highlight 来获取更多帮助。 其实，颜色主题就是一系列的 :highlight 命令的集合。 事实上，大部分颜色主题都包含两套配置。一套适用于例如 xterm 和 iTerm 这样的终端环境（使用前缀 cterm），另一套适用于例如 gvim 和 MacVim 的图形界面环境（使用前缀 gui）。对于上面的例子，ctermbg 就是针对终端环境的，而 guibg 就是针对图形界面环境的。 如果你下载了一个颜色主题，并且在终端环境中打开了 Vim，然后发现显示的颜色与主题截图中差别很大，那很可能是配置文件只设置了图形界面环境的颜色。反之同理，如果你使用的是图形界面环境，发现显示颜色有问题，那就很可能是配置文件只设置了终端环境的颜色。 第二种情况（图形界面环境的显示问题）其实不难解决。如果你使用的是 Neovim 或者 Vim 7.4.1830 的后续版本，可以通过打开真彩色设置来解决显示问题。这就可以让终端环境的 Vim 使用 GUI 的颜色定义，但首先，你要确认一下你的终端环境和环境内的组件（比如 tmux）是否都支持真彩色。可以看一下这篇文档，描述的十分详细。 请参阅以下文档或链接来获取更多帮助： :h 'termguicolors' 主题列表 自定义主题中的颜色 返回主目录 :arrow_heading_up: 折叠 每一部分文字（或者代码）都会有特定的结构。对于存在结构的文字和代码，也就意味着它们可以按照一定的逻辑分割成不同区域。Vim 中的折叠功能，就是按照特定的逻辑把文字和代码折叠成一行，并显示一些简短的描述。折叠功能涉及到很多操作，而且折叠功能可以嵌套使用。 在 Vim 中，有以下 6 中折叠类型： 折叠方式 概述 diff 在「比较窗口」中折叠未改变的文本 expr 使用 'foldexpr' 来创建新的折叠逻辑 indent 基于缩进折叠 manual 使用 zf、zF 或 :fold 来自定义折叠 marker 根据特定的文本标记折叠（通常用于代码注释） syntax 根据语法折叠，比如折叠 if 代码块 注意：折叠功能可能会显著地影响性能。如果你在使用折叠功能的时候出现了打字卡顿之类的问题，请考虑使用 FastFold 插件。这个插件可以让 Vim 按需更新折叠内容，而不是一直调用。 请参阅以下文档获取更多帮助： :h usr_28 :h folds 会话 如果你保存了当前的「视图」（请参阅 :h :mkview），那么当前窗口、配置和按键映射都会被保存下来（请参阅 :h :loadview）。 「会话」就是存储所有窗口的相关设置，以及全局设置。简单来说，就是给当前的 Vim 运行实例拍个照，然后把相关信息存储到会话文件中。存储之后的改动就不会在会话文件中显示，你只需要在改动后更新一下会话文件就可以了。 你可以把当前工作的「项目」存储起来，然后可以在不同的「项目」之间切换。 现在就来试试吧。打开几个窗口和标签，然后执行 :mksession Foo.vim。如果你没有指定文件名，那就会默认保存为 Session.vim。这个文件会保存在当前的目录下，你可以通过 :pwd 来显示当前路径。重启 Vim 之后，你只需要执行 :source Foo.vim，就可以恢复刚才的会话了。所有的缓冲区、窗口布局、按键映射以及工作路径都会恢复到保存时的状态。 其实 Vim 的会话文件就只是 Vim 命令的集合。你可以通过命令 :vs Foo.vim 来看看会话文件中究竟有什么。 你可以决定 Vim 会话中究竟要保存哪些配置，只需要设置一下 'sessionoptions' 就可以了。 为了方便开发，Vim 把最后一次调用或写入的会话赋值给了一个内部变量 v:this_session。 请参阅以下文档来获取更多帮助： :h Session :h 'sessionoptions' :h v:this_session 局部化 以上提到的很多概念，都有一个局部化（非全局）的版本： 全局 局部 作用域 帮助文档 :set :setlocal 缓冲区或窗口 :h local-options :map :map 缓冲区 :h :map-local :autocmd :autocmd * 缓冲区 :h autocmd-buflocal :cd :lcd 窗口 :h :lcd : : 缓冲区 :h maploacalleader 变量也有不同的作用域，详细内容请参考 Vim scripting 的文档。 用法 获取离线帮助 Vim 自带了一套很完善的帮助文档，它们是一个个有固定排版格式的文本文件，通过标签可以访问这些文件的特定位置。 在开始之前先读一下这个章节：:help :help。执行这个命令以后会在新窗口打开 $VIMRUNTIME/doc/helphelp.txt 文件并跳转到这个文件中 :help 标签的位置。 一些关于帮助主题的简单规则： 用单引号把文本包起来表示选项，如：:h 'textwidth' 以小括号结尾表示 VimL 函数，如：:h reverse() 以英文冒号开头表示命令，如：:h :echo 使用快捷键 （这是 ctrl+d）来列出所有包含你当前输入的内容的帮助主题。如：:h tab 会列出所有包含 tab 主题，从 softtabstop 到 setting-guitablabel （译者注：根据安装的插件不同列出的选项也会不同）。 你想查看所有的 VimL 方法吗？很简单，只要输入：:h () 就可以了。你想查看所有与窗口相关的函数吗？输入 :h win*()。 相信你很快就能掌握这些技巧，但是在刚开始的时候，你可能对于该通过什么进行查找一点线索都没有。这时你可以想象一些与要查找的内容相关的关键字，再让 :helpgrep 来帮忙。 :helpgrep backwards 上面的命令会在所有的帮助文件中搜索“backwards”，然后跳转到第一个匹配的位置。所有的匹配位置都会被添加到全局位置信息表，用 :cp / :cn 可以在匹配位置之间进行切换。或者用 :copen 命令来打开全局位置信息表，将光标定位到你想要的位置，再按 回车就可以跳转到该匹配项。详细说明请参考 :h quickfix。 获取离线帮助（补充） 这个列表最初发表在 vim_dev，由 @chrisbra 编辑的，他是 Vim 开发人员中最活跃的一个。 经过一些微小的改动后，重新发布到了这里。 如果你知道你想要找什么，使用帮助系统的搜索会更简单一些，因为搜索出的主题都带有固定的格式。 而且帮助系统中的主题包含了你当前使用的 Vim 版本的所特有特性，而网上那些已经过时或者是早期发布的话题是不会包含这些的。 因此学习使用帮助系统以及它所用的语言是很有必要的。这里是一些例子（不一定全，我有可能忘了一些什么）。 （译者注：下面列表中提及的都是如何指定搜索主题以便快速准确的找到你想要的帮助） 选项要用单引号引起来。用 :h 'list' 来查看列表选项帮助。只有你明确的知道你要找这么一个选项的时候才可以这么做，不然的话你可以用 :h options.txt 来打开所有选项的帮助页面，再用正则表达式进行搜索，如：/width。某些选项有它们自己的命名空间，如：:h cpo-a，:h cpo-A， :h cpo-b 等等。 普通模式的命令不能用冒号作为前缀。使用 :h gt 来转到“gt”命令的帮助页面。 正则表达式以“/”开头，所以 :h /\\+ 会带你到正则表达式中量词“+”的帮助页面。 组合键经常以一个字母开头表示它们可以在哪些模式中使用。如：:h i_CTRL-X 会带你到插入模式下的 CTRL-X 命令的用法帮助页面，这是一个自动完成类的组合键。需要注意的是某些键是有固定写法的，如 Control 键写成 CTRL。还有，查找普通模式下的组合键帮助时，可以省略开头的字母“n”，如：:h CTRL-A。而 :h c_CTRL-A（译者注：原文为 :h c_CRTL-R，感觉改为 A 更符合上下文语境）会解释 CTRL-A 在命令模式下输入命令时的作用；:h v_CTRL-A 说的是在可见模式下把光标所在处的数字加 1；:h g_CTRL-A 则说的是 g 命令（你需要先按 \"g\" 的命令）。这里的 \"g\" 代表一个普通的命令，这个命令总是与其它的按键组合使用才生效，与 \"z\" 开始的命令相似。 寄存器是以 \"quote\" 开头的。如：:h quote: （译者注：原文为:h quote，感觉作者想以\":\"来举例）来查看关于\":\"寄存器的说明。 关于 Vim 脚本（VimL）的帮助都在 :h eval.txt 里。而某些方面的语言可以使用 :h expr-X 获取帮助，其中的 'X' 是一个特定的字符，如：:h expr-! 会跳转到描述 VimL 中'!'（非）的章节。另外一个重要提示，可以使用 :h function-list 来查看所有函数的简要描述，列表中包括函数名和一句话描述。 关于映射都可以在 :h map.txt 中找到。通过 :h mapmode-i 来查找 :imap 命令的相关信息；通过 :h map-topic 来查找专门针对映射的帮助（译者注：topic 为一个占位符，正如上面的字符 'X' 一样，在实际使用中需要替换成相应的单词）（如：:h :map-local 查询本地 buffer 的映射，:h map-bar 查询如何在映射中处理'|')。 命令定义用 \"command-\" 开头，如用 :h command-bar 来查看自定义命令中'!'的作用。 窗口管理类的命令是以 \"CTRL-W\" 开头的，所以你可以用 :h CTRL-W_* 来查找相应的帮助（译者注：'*'同样为占位符）（如：:h CTRL-W_p 查看切换到之前访问的窗口命令的解释）。如果你想找窗口处理的命令，还可以通过访问 :h windows.txt 并逐行向下浏览，所有窗口管理的命令都在这里了。 执行类的命令以\":\"开头，即：:h :s 讲的是 \":s\" 命令。 在输入某个话题时按 CTRL-D，让 Vim 列出所有的近似项辅助你输入。 用 :helpgrep 在所有的帮助页面（通常还包括了已安装的插件的帮助页面）中进行搜索。参考 :h :helpgrep 来了解如何使用。当你搜索了一个话题之后，所有的匹配结果都被保存到了全局位置信息表（或局部位置信息表）当中，可以通过 :copen 或 :lopen 打开。在打开的窗口中可能通过 / 对搜索结果进行进一步的过滤。 :h helphelp 里介绍了如何使用帮助系统。 用户手册。它采用了一种对初学者更加友好的方式来展示帮助话题。用 :h usr_toc.txt 打开目录（你可能已经猜到这个命令的用处了）。浏览用户手册能帮助你找出某些你想了解的话题，如你可以在第 24 章看到关于“复合字符”以及“输入特殊字符”的讲解（用 :h usr_24.txt 可以快速打开相关章节）。 高亮分组的帮助以 hl- 开头。如：:h hl-WarningMsg 说的是警告信息分组的高亮。 语法高亮以:syc- 开头，如：:h :syn-conceal 讲的是 :syn 命令的对于隐藏字符是如何显示的。 快速修复命令以 :c 开头，而位置列表命令以 :l 开头。 :h BufWinLeave 讲的是 BufWinLeave 自动命令。还有，:h autocommand-events （译者注：原文是 :h autocommands-events，但是没有该帮助）讲的是所有可用的事件。 启动参数都以“-”开头，如：:h -f 会告诉你 Vim 中 “-f” 参数的作用。 额外的特性都以“+”开头，如：:h +conceal 讲的是关于隐藏字符的支持。 错误代码可以在帮助系统中直接查到。:h E297 会带你到关于这一错误的详细解释。但是有时并没有转到错误描述，而是列出了经常导出这一错误的 Vim 命令，如 :h E128 （译者注：原文为:h hE128，但是并没有该帮助）会直接跳转到 :function 命令。 关于包含的语法文件的文档的帮助话题格式是 :h ft-*-syntax。如：:h ft-c-syntax 说的就是 C 语言语法文件以及它所提供的选项。有的语法文件还会带有自动完成（:h ft-php-omni）或文件类型插件（:h ft-tex-plugin）相关的章节可以查看。 另外在每个帮助页的顶端通常会包含一个用户文档链接（更多的从从用户的角度出发来主角命令的功能和用法，不涉及那么多细节）。如：:h pattern.txt 里包含了 :h 03.9 和 :h usr_27 两个章节的链接。 获取在线帮助 如果你遇到了无法解决的问题，或者需要指引的话，可以参考 Vim 使用邮件列表。 IRC 也是一个很不错的资源。 Freenode 上的 #vim 频道很庞大，并且里面有许多乐于助人的人。 如果你想给 Vim 提交 Bug 的话，可以使用 vim_dev 邮件列表。 执行自动命令 你可以触发任何事件，如：:doautocmd BufRead。 用户自定义事件 对于插件而言，创建你自己的自定义事件有时非常有用。 function! Chibby() \" A lot of stuff is happening here. \" And at last.. doautocmd User ChibbyExit endfunction 现在你插件的用户可以在 Chibby 执行完成之后做任何他想做的事情： autocmd User ChibbyExit call ChibbyCleanup() 顺便提一句，如果在使用 :autocmd 或 :doautocmd 时没有捕捉异常，那么会输出 \"No matching autocommands\" 信息。这也是为什么许多插件用 silent doautocmd ... 的原因。但是这也会有不足，那就是你不能再在 :autocmd 中使用 echo \"foo\" 了，取而代之的是你要使用 unsilent echo \"foo\" 来输出。 这就是为什么要在触发事件之前先判断事件是否存在的原因， if exists('#User#ChibbyExit') doautocmd User ChibbyExit endif 帮助文档：:h User 事件嵌套 默认情况下，自动命令不能嵌套！如果某个自动命令执行了一个命令，这个命令再依次触发其它的事件，这是不可能的。 例如你想在每次启动 Vim 的时候自动打开你的 vimrc 文件： autocmd VimEnter * edit $MYVIMRC 当你启动 Vim 的时候，它会帮你打开你的 vimrc 文件，但是你很快会注意到这个文件没有任何的高亮，尽管平时它是正常可以高亮的。 问题在于你的非嵌套自动命令 :edit 不会触发“BufRead”事件，所以并不会把文件类型设置成“vim”，进而 $VIMRUNTIME/syntax/vim.vim 永远不会被引入。详细信息请参考：:au BufRead *.vim。要想完成上面所说的需求，使用下面这个命令： autocmd VimEnter * nested edit $MYVIMRC 帮助文档：:h autocmd-nested 剪切板 如果你想在没有 GUI 支持的 Unix 系统中使用 Vim 的 'clipboard' 选项，则需要 +clipboard 以及可选的 +xterm_clipboard 两个特性支持。 帮助文档： :h 'clipboard' :h gui-clipboard :h gui-selections 另外请参考：持续粘贴（为什么我每次都要设置 'paste' 模式 剪贴板的使用（Windows, OSX） Windows 自带了剪贴板.aspx>)，OSX 则带了一个粘贴板 在这两个系统中都可以用大家习惯用的 ctrl+c / cmd+c 复制选择的文本，然后在另外一个应用中用 ctrl+v / cmd+v 进行粘贴。 需要注意的是复制的文本已经被发送到了剪贴板，所以你在粘贴复制的内容之前关闭这个应用是没有任何问题的。 每次复制的时候，都会向剪贴板寄存器 * 中写入数据。 而在 Vim 中分别使用 \"*y 和 \"*p 来进行复制（yank) 和 粘贴（paste)。 如果你不想每次操作都要指定 * 寄存器，可以在你的 vimrc 中添加如下配置： set clipboard=unnamed 通常情况下复制/删除/放入操作会往 \" 寄存器中写入数据，而加上了上面的配置之后 * 寄存器也会被写入同样数据，因此简单的使用 y 和 p 就可以复制粘贴了。 我再说一遍：使用上面的选项意味着每一次的复制/粘贴，即使在同一个 Vim 窗口里，都会修改剪贴板的内容。你自己决定上面的选项是否适合。 如果你觉得输入 y 还是太麻烦的话，可以使用下面的设置把在可视模式下选择的内容发送到剪贴板： set clipboard=unnamed,autoselect set guioptions+=a 帮助文档： :h clipboard-unnamed :h autoselect :h 'go_a' 剪贴板的使用（Linux, BSD, ...） 如果你的系统使用了 X 图形界面，事情会变得有一点不同。X 图形界面实现了 X 窗口系统协议, 这个协议在 1987 年发布的主版本 11，因此 X 也通常被称为 X11。 在 X10 版本中，剪贴缓冲区被用来实现像 clipboard 一样由 X 来复制文本，并且可以被所有的程序访问。现在这个机制在 X 中还存在，但是已经过时了，很多程序都不再使用这一机制。 近年来数据在程序之间是通过选择进行传递的。一共有三种选择，经常用到的有两种：PRIMARY 和 CLIPBOARD。 选择的工作工模大致是这样的： Program A： Program A：声称对 CLIPBOARD 的所有权 Program B： Program B：发现CLIPBOARD的所有权被Program A持有 Program B：从Program A请求数据 Program A：响应这个请求并发送数据给Program B Program B：从Program A接收数据并插入到窗口中 选择 何时使用 如何粘贴 如何在 Vim 中访问 PRIMARY 选择文本 鼠标中键, shift+insert * 寄存器 CLIPBOARD 选择文本并按 ctrl+c ctrl+v +寄存器 注意：X 服务器并不会保存选择（不仅仅是 CLIPBOARD 选择）！因此在关闭了相应的程序后，你用 ctrl+c 复制的内容将丢失。 使用 \"*p 来贴粘 PRIMARY 选择中的内容，或者使用 \"+y1G 来将整个文件的内容复制到 CLIPBOARD 选择。 如果你需要经常访问这两个寄存器，可以考虑使用如下配置： set clipboard^=unnamed \" * 寄存器 \" 或者 set clipboard^=unnamedplus \" + 寄存器 （^= 用来将设置的值加到默认值之前，详见：:h :set^=） 这会使得所有复制/删除/放入操作使用 * 或 + 寄存器代替默认的未命令寄存器 \"。之后你就可以直接使用 y 或 p 访问你的 X 选择了。 帮助文档： :h clipboard-unnamed :h clipboard-unnamedplus 打开文件时恢复光标位置 如果没有这个设置，每次打开文件时光标都将定位在第一行。而加入了这个设置以后，你就可以恢复到上次关闭文件时光标所在的位置了。 将下面的配置添加到你的 vimrc 文件： autocmd BufReadPost * \\ if line(\"'\\\"\") > 1 && line(\"'\\\"\") 这是通过判断之前的光标位置是否存在（文件可能被其它程序修改而导致所记录的位置已经不存在了），如果存在的话就执行 g`\" （转到你离开时的光标位置但是不更改跳转列表）。 这需要使用 viminfo 文件：:h viminfo-。 临时文件 根据选项的不同， Vim 最多会创建 4 种工作文件。 备份文件 你可以让 Vim 在将修改写入到文件之前先备份原文件。默认情况下， Vim 会保存一个备份文件但是当修改成功写入后会立即删除它（:set writebackup）。如果你想一直保留这个备份文件的话，可以使用 :set backup。而如果你想禁用备份功能的话，可以使用 :set nobackup nowritebackup。 咱们来看一下上次我在 vimrc 中改了什么： $ diff ~/.vim/vimrc ~/.vim/files/backup/vimrc-vimbackup 390d389 帮助文档：:h backup 交换文件 假设你有一个非常棒的科幻小说的构思。在按照故事情节已经写了好几个小时几十万字的时候..忽然停电了！而那时你才想起来你上次保存 ~/来自外太空的邪恶入侵者.txt 是在.. 好吧，你从来没有保存过。 但是并非没有希望了！在编辑某个文件的时候， Vim 会创建一个交换文件，里面保存的是对当前文件所有未保存的修改。自己试一下，打开任意的文件，并使用 :swapname 获得当前的交换文件的保存路径。你也可以将 :set noswapfile 加入到 vimrc 中来禁用交换文件。 默认情况下，交换文件会自动保存在被编辑文件所在的目录下，文件名以 .file.swp 后缀结尾，每当你修改了超过 200 个字符或是在之前 4 秒内没有任何动作时更新它的内容，在你不再编辑这个文件的时候会被删除。你可以自己修改这些数字，详见：:h 'updatecount' 和 :h 'updatetime'。 而在断电时，交换文件并不会被删除。当你再次打开 vim ~/来自外太空的邪恶入侵者.txt 时， Vim 会提示你恢复这个文件。 帮助文档：:h swap-file 和 :h usr_11 撤销文件 内容变更历史记录是保存在内存中的，并且会在 Vim 退出时清空。如果你想让它持久化到磁盘中，可以设置 :set undofile。这会把文件 ~/foo.c 的撤销文件保存在 ~/foo.c.un~。 帮助文档：:h 'undofile' 和 :h undo-persistence viminfo 文件 备份文件、交换文件和撤销文件都是与文本状态相关的，而 viminfo 文件是用来保存在 Vim 退出时可能会丢失的其它的信息的。包括历史记录（命令历史、搜索历史、输入历史）、寄存器内容、标注、缓冲区列表、全局变量等等。 默认情况下，viminfo 被保存在 ~/.viminfo。 帮助文档：:h viminfo 和 :h 'viminfo' 临时文件管理设置示例 如果你跟我一样，也喜欢把这些文件放到一个位置（如：~/.vim/files）的话，可以使用下面的配置： \" 如果文件夹不存在，则新建文件夹 if !isdirectory($HOME.'/.vim/files') && exists('*mkdir') call mkdir($HOME.'/.vim/files') endif \" 备份文件 set backup set backupdir =$HOME/.vim/files/backup/ set backupext =-vimbackup set backupskip = \" 交换文件 set directory =$HOME/.vim/files/swap// set updatecount =100 \" 撤销文件 set undofile set undodir =$HOME/.vim/files/undo/ \" viminfo 文件 set viminfo ='100,n$HOME/.vim/files/info/viminfo 注意：如果你在一个多用户系统中编辑某个文件时， Vim 提示你交换文件已经存在的话，可能是因为有其他的用户此时正在编辑这个文件。而如果将交换文件放到自己的 home 目录的话，这个功能就失效了。因此服务器非常不建议将这些文件修改到 HOME 目录，避免多人同时编辑一个文件，却没有任何警告。 编辑远程文件 Vim 自带的 netrw 插件支持对远程文件的编辑。实际上它将远程的文件通过 scp 复制到本地的临时文件中，再用那个文件打开一个缓冲区，然后在保存时把文件再复制回远程位置。 下面的命令在你本地的 VIM 配置与 SSH 远程服务器上管理员想让你使用的配置有冲突时尤其有用： :e scp://bram@awesome.site.com/.vimrc 如果你已经设置了 ~/.ssh/config，SSH 会自动读取这里的配置： Host awesome HostName awesome.site.com Port 1234 User bram 如果你的 ~/.ssh/config 中有以上的内容，那么下面的命令就可以正常执行了： :e scp://awesome/.vimrc 可以用同样的方法编辑 ~/.netrc, 详见：:h netrc-netrc。 确保你已经看过了 :h netrw-ssh-hack 和 :h g:netrw_ssh_cmd。 另外一种编辑远程文件的方法是使用 sshfs，它会用 FUSE 来挂载远程的文件系统到你本地的系统当中。 插件管理 Pathogen是第一个比较流行的插件管理工具。实际上它只是修改了 runtimepath （:h 'rtp'） 来引入所有放到该目录下的文件。你需要自己克隆插件的代码仓库到那个目录。 真正的插件管理工具会在 Vim 中提供帮助你安装或更新插件的命令。以下是一些常用的插件管理工具： dein plug vim-addon-manager vundle 多行编辑 这是一种可以同时输入多行连续文本的技术。参考这个示例。 用 切换到可视块模式。然后向下选中几行，按 I 或 A （译者注：大写字母，即 shift+i 或 shift+a）然后开始输入你想要输入的文本。 在刚开始的时候可能会有些迷惑，因为文本只出现在了当前编辑的行，只有在当前的插入动作结束后，之前选中的其它行才会出现插入的文本。 举一个简单的例子：3jItext。 如果你要编辑的行长度不同，但是你想在他们后面追加相同的内容的话，可以试一下这个：3j$Atext。 有时你可能需要把光标放到当前行末尾之后，默认情况下你是不可能做到的，但是可能通过设置 virtualedit 选项达到目的： set virtualedit=all 设置之后 $10l 或 90| 都会生效，即使超过了行尾的长度。 详见 :h blockwise-examples。在开始的时候可能会觉得有些复杂，但是它很快就会成为你的第二天性的。 如果你想探索更有趣的事情，可以看看多光标 使用外部程序和过滤器 免责声明：Vim 是单线程的，因此在 Vim 中以前端进程执行其它的程序时会阻止其它的一切。当然你可以使用 Vim 程序接口，如 Lua，并且使用它的多线程支持，但是在那期间， Vim 的处理还是被阻止了。Neovim 添加了任务 API 解决了此问题。 （据说 Bram 正在考虑在 Vim 中也添加任务控制。如果你使用了较新版本的的 Vim ，可以看一下 :helpgrep startjob。） 使用 :! 启动一个新任务。如果你想列出当前工作目录下的所有文件，可以使用 :!ls。 用 | 来将结果通过管道重定向，如：:!ls -l | sort | tail -n5。 没有使用范围时（译者注：范围就是 : 和 ! 之间的内容，. 表示当前行，+4 表示向下偏移 4 行，$ 表示最末行等，多行时用 , 将它们分开，如 .,$ 表示从当前行到末行），:! 会显示在一个可滚动的窗口中（译者注：在 GVim 和在终端里运行的结果稍有不同）。相反的，如果指定了范围，这些行会被过滤>)。这意味着它们会通过管道被重定向到过滤程序的 stdin，在处理后再通过过滤程序的 stdout 输出，用输出结果替换范围内的文本。例如：为接下来的 5 行文本添加行号，可以使用： :.,+4!nl -ba -w1 -s' ' 由于手动添加范围很麻烦， Vim 提供了一些辅助方法以方便的添加范围。如果需要经常带着范围的话，你可以在可见模式中先选择，然后再按 : （译者注：选中后再按 ! 更方便）。还可以使用 ! 来取用一个 motion 的范围，如 !ipsort （译者注：原文为 !ip!sort ，但经过实验发现该命令执行报错，可能是因为 Vim 版本的原因造成的，新版本使用 ip 选择当前段落后自动在命令后添加了 ! ，按照作者的写法来看，可能之前的版本没有自动添加 ! ）可以将当前段落的所有行按字母表顺序进行排序。 一个使用过滤器比较好的案例是Go 语言。它的缩进语法非常个性，甚至还专门提供了一个名为 gofmt 的过滤器来对 Go 语言的源文件进行正确的缩进。Go 语言的插件通常会提供一个名为 :Fmt 的函数，这个函数就是执行了 :%!gofmt 来对整个文件进行缩进。 人们常用 :r !prog 将 prog 程序的插入放到当前行的下面，这对于脚本来说是很不错的选择，但是在使用的过程中我发现 !!ls 更加方便，它会用输出结果替换当前行的内容。（译者注：前面命令中的 prog 只是个占位符，在实际使用中需要替换成其它的程序，如 :r !ls，这就与后面的 !!ls 相对应了，两者唯一的不同是第一个命令不会覆盖当前行内容，但是第二个命令会） 帮助文档： :h filter :h :read! Cscope Cscope 的功能比 ctags 要完善，但是只支持 C（通过设置 cscope.files 后同样支持 C++以及 Java）。 鉴于 Tag 文件只是知道某个符号是在哪里定义的，cscope 的数据库里的数据信息就多的多了： 符号是在哪里定义的？ 符号是在哪里被使用的？ 这个全局符号定义了什么？ 这个变量是在哪里被赋值的？ 这个函数在源文件的哪个位置？ 哪些函数调用了这个函数？ 这个函数调用了哪些函数？ \"out of space\"消息是从哪来的？ 在目录结构中当前的源文件在哪个位置？ 哪些文件引用了这个头文件？ 1. 构建数据库 在你项目的根目录执行下面的命令： $ cscope -bqR 这条命令会在当前目录下创建三个文件：cscope{,.in,.po}.out 。把它们想象成你的数据库。 不幸的时 cscope 默认只分析 *.[c|h|y|l] 文件。如果你想在 Java 项目中使用 cscope ，需要这样做： $ find . -name \"*.java\" > cscope.files $ cscope -bq 2. 添加数据库 打开你新创建的数据库连接： :cs add cscope.out 检查连接已经创建成功： :cs show （当然你可以添加多个连接。） 3. 查询数据库 :cs find 如：:cs find d foo 会列出 foo(...) 调用的所有函数。 Kind 说明 s symbol：查找使用该符号的引用 g global：查找该全局符号的定义 c calls：查找调用当前方法的位置 t text：查找出现该文本的位置 e egrep：使用 egrep 搜索当前单词 f file：打开文件名 i includes：查询引入了当前文件的文件 d depends：查找当前方法调用的方法 推荐一些比较方便的映射，如： nnoremap cs :cscope find s =expand('') nnoremap cg :cscope find g =expand('') nnoremap cc :cscope find c =expand('') nnoremap ct :cscope find t =expand('') nnoremap ce :cscope find e =expand('') nnoremap cf :cscope find f =expand('') nnoremap ci :cscope find i ^=expand('')$ nnoremap cd :cscope find d =expand('') 所以 :tag （或 ）跳转到标签定义的文件，而 :cstag 可以达到同样的目的，同时还会打开 cscope 的数据库连接。'cscopetag' 选项使得 :tag 命令自动的像 :cstag 一样工作。这在你已经使用了基于标签的映射时会非常方便。 帮助文档：:h cscope MatchIt 由于 Vim 是用 C 语言编写的，因此许多功能都假设使用类似 C 语言的语法。默认情况下，如果你的光标在 { 或 #endif , 就可以使用 % 跳转到与之匹配的 } 或 #ifdef。 Vim 自带了一个名为 matchit.vim 的插件，但是默认没有启用。启用后可以用 % 在 HTML 相匹配的标签或 VimL 的 if/else/endif 块之间进行跳转，它还带来了一些新的命令。 在 Vim 8 中安装 \" vimrc packadd! matchit 在 Vim 7 或者更早的版本中安装 \"vimrc runtime macros/matchit.vim 由于 matchit 的文档很全面，我建议安装以后执行一次下面的命令： :!mkdir -p ~/.vim/doc :!cp $VIMRUNTIME/macros/matchit.vim ~/.vim/doc :helptags ~/.vim/doc 简短的介绍 至此这个插件已经可以使用了。 参考 :h matchit-intro 来获得支持的命令以及 :h matchit-languages 来获得支持的语言。 你可以很方便的定义自己的匹配对，如： autocmd FileType python let b:match_words = '\\:\\:\\' 之后你就可以在任何的 Python 文件中使用 % （向前）或 g% （向后）在这三个片断之间跳转了。 帮助文档： :h matchit-install :h matchit :h b:match_words 技巧 跳至选择的区域另一端 在使用 v 或者 V 选择某段文字后，可以用 o 或者 O 按键跳至选择区域的开头或者结尾。 :h v_o :h v_O 聪明地使用 n 和 N n 与 N 的实际跳转方向取决于使用 / 还是 ? 来执行搜索，其中 / 是向后搜索，? 是向前搜索。一开始我（原作者）觉得这里很难理解。 如果你希望 n 始终为向后搜索，N 始终为向前搜索，那么只需要这样设置： nnoremap n 'Nn'[v:searchforward] nnoremap N 'nN'[v:searchforward] 聪明地使用命令行历史 我（原作者）习惯用 Ctrl + p 和 Ctrl + n 来跳转到上一个/下一个条目。其实这个操作也可以用在命令行中，快速调出之前执行过的命令。 不仅如此，你会发现 上 和 下 其实更智能。如果命令行中已经存在了一些文字，我们可以通过按方向键来匹配已经存在的内容。比如，命令行中现在是 :echo，这时候我们按 上，就会帮我们补全成 :echo \"Vim rocks!\"（前提是，之前输入过这段命令）。 当然，Vim 用户都不愿意去按方向键，事实上我们也不需要去按，只需要设置这样的映射： cnoremap cnoremap 这个功能，我（原作者）每天都要用很多次。 智能 Ctrl-l Ctrl + l 的默认功能是清空并「重新绘制」当前的屏幕，就和 :redraw! 的功能一样。下面的这个映射就是执行重新绘制，并且取消通过 / 和 ? 匹配字符的高亮，而且还可以修复代码高亮问题（有时候，由于多个代码高亮的脚本重叠，或者规则过于复杂，Vim 的代码高亮显示会出现问题）。不仅如此，还可以刷新「比较模式」（请参阅 :help diff-mode）的代码高亮： nnoremap l :nohlsearch:diffupdate:syntax sync fromstart 禁用错误报警声音和图标 set noerrorbells set novisualbell set t_vb= 请参阅 Vim Wiki: Disable beeping。 快速移动当前行 有时，我（原作者）想要快速把当前行上移或下移一行，只需要这样设置映射： nnoremap [e :execute 'move -1-'. v:count1 nnoremap ]e :execute 'move +'. v:count1 这个映射，同样可以搭配数字使用，比如连续按下 2 ] e 就可以把当前行向下移动两行。 快速添加空行 nnoremap [ :put! =repeat(nr2char(10), v:count1)'[ nnoremap ] :put =repeat(nr2char(10), v:count1) 设置之后，连续按下 5 [ 空格 在当前行上方插入 5 个空行。 运行时检测 需要的特性：+profile Vim 提供了一个内置的运行时检查功能，能够找出运行慢的代码。 :profile 命令后面跟着子命令来确定要查看什么。 如果你想查看所有的： :profile start /tmp/profile.log :profile file * :profile func * Vim 不断地在内存中检查信息，只在退出的时候输出出来。（Neovim 已经解决了这个问题用 :profile dump 命令） 看一下 /tmp/profile.log 文件，检查时运行的所有代码都会被显示出来，包括每一行代码运行的频率和时间。 大多数代码都是用户不熟悉的插件代码，如果你是在解决一个确切的问题， 直接跳到这个日志文件的末尾，那里有 FUNCTIONS SORTED ON TOTAL TIME 和 FUNCTIONS SORTED ON SELF TIME 两个部分，如果某个 function 运行时间过长一眼就可以看到。 查看启动时间 感觉 Vim 启动的慢？到了研究几个数字的时候了： vim --startuptime /tmp/startup.log +q && vim /tmp/startup.log 第一栏是最重要的因为它显示了绝对运行时间，如果在前后两行之间时间差有很大的跳跃，那么是第二个文件太大或者含有需要检查的错误的 VimL 代码。 NUL 符用新行表示 文件中的 NUL 符 （\\0），在内存中被以新行（\\n）保存，在缓存空间中显示为 ^@。 更多信息请参看 man 7 ascii 和 :h NL-used-for-Nul 。 快速编辑自定义宏 这个功能真的很实用！下面的映射，就是在一个新的命令行窗口中读取某一个寄存器（默认为 *）。当你设置完成后，只需要按下 回车 即可让它生效。 在录制宏的时候，我经常用这个来更改拼写错误。 nnoremap m :='let @'. v:register .' = '. string(getreg(v:register)) 只需要连续按下 leader m 或者 \" leader m 就可以调用了。 请注意，这里之所以要写成 是为了确保 执行了。请参阅 :h c_^R^R 快速跳转到源(头)文件 这个技巧可以用在多种文件类型中。当你从源文件或者头文件中切换到其他文件的时候，这个技巧可以设置「文件标记」（请参阅 :h marks），然后你就可以通过连续按下 ' C 或者 ' H 快速跳转回去（请参阅 :h 'A）。 autocmd BufLeave *.{c,cpp} mark C autocmd BufLeave *.h mark H 注意：由于这个标记是设置在 viminfo 文件中，因此请先确认 :set viminfo? 中包含了 :h viminfo-'。 在 GUI 中快速改变字体大小 印象中，我（原作者）记得一下代码是来自 tpope's 的配置文件： command! Bigger :let &guifont = substitute(&guifont, '\\d\\+$', '\\=submatch(0)+1', '') command! Smaller :let &guifont = substitute(&guifont, '\\d\\+$', '\\=submatch(0)-1', '') 根据模式改变光标类型 我（原作者）习惯在普通模式下用块状光标，在插入模式下用条状光标（形状类似英文 \"I\" 的样子），然后在替换模式中使用下划线形状的光标。 if empty($TMUX) let &t_SI = \"\\]50;CursorShape=1\\x7\" let &t_EI = \"\\]50;CursorShape=0\\x7\" let &t_SR = \"\\]50;CursorShape=2\\x7\" else let &t_SI = \"\\Ptmux;\\\\]50;CursorShape=1\\x7\\\\\\\" let &t_EI = \"\\Ptmux;\\\\]50;CursorShape=0\\x7\\\\\\\" let &t_SR = \"\\Ptmux;\\\\]50;CursorShape=2\\x7\\\\\\\" endif 原理很简单，就是让 Vim 在进入和离开插入模式的时候，输出一些序列，请参考 escape sequence。Vim 与终端之间的中间层，比如 tmux 会处理并执行上面的代码。 但上面这个还是有一个缺点的。终端环境的内部原理不尽相同，对于序列的处理方式也稍有不同。因此，上面的代码可能无法在你的环境中运行。甚至，你的运行环境也有可能不支持其他光标形状，请参阅你的 Vim 运行环境的文档。 好消息是，上面这个代码，可以在 iTerm2 中完美运行。 防止水平滑动的时候失去选择 如果你选中了一行或多行，那么你可以用 或 > 来调整他们的缩进。但在调整之后就不会保持选中状态了。> 你可以连续按下 g v 来重新选中他们，请参考 :h gv。因此，你可以这样来配置映射： xnoremap >gv 设置好之后，在可视模式中使用 >>>>> 就不会再出现上面提到的问题了。 选择当前行至结尾，排除换行符 在 Vim 里，我们可以同过 v$ 选择当前行至结尾，但此时会把最后一个换行符也选中，通常需要按额外的 h 来取消最后选中最后一个换行符号。 Vim 提供了一个 g_ 快捷键，可以移动光标至最后一个非空字符。因此，为达到次效果，可以使用 vg_。当然，如果觉得按三个键比较麻烦， 可以添加一个映射： nnoremap L g_ 这样就可以通过 vL 达到一样的效果了。 重新载入保存文件 通过自动命令，你可以在保存文件的同时触发一些其他功能。比如，如果这个文件是一个配置文件，那么就重新载入；或者你还可以对这个文件进行代码风格检查。 autocmd BufWritePost $MYVIMRC source $MYVIMRC autocmd BufWritePost ~/.Xdefaults call system('xrdb ~/.Xdefaults') 更加智能的当前行高亮 我（原作者）很喜欢「当前行高亮」（请参阅 :h cursorline）这个功能，但我只想让这个效果出现在当前窗口，而且在插入模式中关闭这个效果： autocmd InsertLeave,WinEnter * set cursorline autocmd InsertEnter,WinLeave * set nocursorline 更快的关键字补全 关键字补全（ 或 ）功能的工作方式是，无论 'complete' 设置中有什么，它都会尝试着去补全。这样，一些我们用不到的标签也会出现在补全列表中。而且，它会扫描很多文件，有时候运行起来非常慢。如果你不需要这些，那么完全可以像这样把它们禁用掉： set complete-=i \" disable scanning included files set complete-=t \" disable searching tags 改变颜色主题的默认外观 如果你想让状态栏在颜色主题更改后依然保持灰色，那么只需要这样设置： autocmd ColorScheme * highlight StatusLine ctermbg=darkgray cterm=NONE guibg=darkgray gui=NONE 同理，如果你想让某一个颜色主题（比如 \"lucius\"）的状态栏为灰色（请使用 :echo color_name 来查看当前可用的所有颜色主题）： autocmd ColorScheme lucius highlight StatusLine ctermbg=darkgray cterm=NONE guibg=darkgray gui=NONE 命令 下面的命令都比较有用，最好了解一下。用 :h : 来了解更多关于它们的信息，如：:h :global。 :global 和 :vglobal - 在所有匹配行执行命令 在所有符合条件的行上执行某个命令。如： :global /regexp/ print 会在所有包含 \"regexp\" 的行上执行 print 命令（译者注：regexp 有正则表达式的意思，该命令同样支持正则表达式，在所有符合正则表达式的行上执行指定的命令）。 趣闻：你们可能都知道老牌的 grep 命令，一个由 Ken Thompson 编写的过滤程序。它是干什么用的呢？它会输出所有匹配指定正则表达式的行！现在猜一下 :global /regexp/ print 的简写形式是什么？没错！就是 :g/re/p 。 Ken Thompsom 在编写 grep 程序的时候是受了 vi :global 的启发。（译者注： https://robots.thoughtbot.com/how-grep-got-its-name） 既然它的名字是 :global，理应仅作用在所有行上，但是它也是可以带范围限制的。假设你想使用 :delete 命令删除从当前行到下一个空行（由正则表达式 ^$ 匹配）范围内所有包含 \"foo\" 的行： :,/^$/g/foo/d 如果要在所有 不 匹配的行上执行命令的话，可以使用 :global! 或是它的别名 :vglobal （ V 代表的是 inVerse ）。 :normal 和 :execute - 脚本梦之队 这两个命令经常在 Vim 的脚本里使用。 借助于 :normal 可以在命令行里进行普通模式的映射。如：:normal! 4j 会令光标下移 4 行（由于加了\"!\"，所以不会使用自定义的映射 \"j\"）。 需要注意的是 :normal 同样可以使用范围数（译者注：参考 :h range 和 :h :normal-range 了解更多），故 :%norm! Iabc 会在所有行前加上 \"abc\"。 借助于 :execute 可以将命令和表达式混合在一起使用。假设你正在编辑一个 C 语言的文件，想切换到它的头文件： :execute 'edit' fnamemodify(expand('%'), ':r') . '.h' （译者注：头文件为与与源文件同名但是扩展名为 .h 的文件。上面的命令中 expand 获得当前文件的名称，fnamemodify 获取不带扩展名的文件名，再连上 '.h' 就是头文件的文件名了，最后在使用 edit 命令打开这个头文件。） 这两个命令经常一起使用。假设你想让光标下移 n 行： :let n = 4 :execute 'normal!' n . 'j' 重定向消息 许多命令都会输出消息，:redir 用来重定向这些消息。它可以将消息输出到文件、寄存器或是某个变量中。 \" 将消息重定向到变量 `neatvar` 中 :redir => neatvar \" 打印所有寄存器的内容 :reg \" 结束重定向 :redir END \" 输出变量 :echo neatvar \" 恶搞一下，我们把它输出到当前缓冲区 :put =neatvar 再 Vim 8 中，可以更简单的方式即位： :put =execute('reg') （译者注：原文最后一条命令是 :put =nicevar 但是实际会报变量未定义的错误） （实测 neovim/vim8 下没问题） 帮助文档：:h :redir 调试 常规建议 如果你遇到了奇怪的行为，尝试用这个命令重现它： vim -u NONE -N 这样会在不引用 vimrc（默认设置）的情况下重启 vim，并且在 nocompatible 模式下（使用 vim 默认设置而不是 vi 的）。（搜索 :h --noplugin 命令了解更多启动加载方式） 如果仍旧能够出现该错误，那么这极有可能是 vim 本身的 bug，请给 vim_dev 发送邮件反馈错误，多数情况下问题不会立刻解决，你还需要进一步研究 许多插件经常会提供新的（默认的/自动的）操作。如果在保存的时候发生了，那么请用 :verb au BufWritePost 命令检查潜在的问题 如果你在使用一个插件管理工具，将插件行注释调，再进行调试。 问题还没有解决？如果不是插件的问题，那么肯定是你的自定义的设置的问题，可能是你的 options 或 autocmd 等等。 到了一行行代码检查的时候了，不断地排除缩小检查范围知道你找出错误，根据二分法的原理你不会花费太多时间的。 在实践过程中，可能就是这样，把 :finish 放在你的 vimrc 文件中间，Vim 会跳过它之后的设置。如果问题还在，那么问题就出在:finish之前的设置中，再把:finish放到前一部分设置的中间位置。否则问题就出现在它后面的半部分设置，那么就把:finish放到后半部分的中间位置。不断的重复即可找到。 调整日志等级 Vim 现在正在使用的另一个比较有用的方法是增加 debug 信息输出详细等级。现在 Vim 支持 9 个等级，可以用:h 'verbose'命令查看。 :e /tmp/foo :set verbose=2 :w :set verbose=0 这可以显示出所有引用的文件、没有变化的文件或者各种各样的作用于保存的插件。 如果你只是想用简单的命令来提高等级，也是用 :verbose ，放在其他命令之前，通过计数来指明等级，默认是 1. :verb set verbose \" verbose=1 :10verb set verbose \" verbose=10 通常用等级 1 来显示上次从哪里设置的选项 :verb set ai? \" Last set from ~/.vim/vimrc 一般等级越高输出信息月详细。但是不要害怕，亦可以把输出导入到文件中： :set verbosefile=/tmp/foo | 15verbose echo \"foo\" | vsplit /tmp/foo 你可以一开始的时候就打开 verbosity，用 -V 选项，它默认设置调试等级为 10。 例如：vim -V5 查看启动日志 查看运行时日志 Vim 脚本调试 如果你以前使用过命令行调试器的话，对于:debug命令你很快就会感到熟悉。 只需要在任何其他命令之前加上:debug就会让你进入调试模式。也就是，被调试的 Vim 脚本会在第一行停止运行，同时该行会被显示出来。 想了解可用的 6 个调试命令，可以查阅:h >cont和阅读下面内容。需要指出的是，类似 gdb 和其他相似调试器，调试命令可以使用它们的简短形式：c、 q、n、s、 i和 f。 除了上面的之外，你还可以自由地使用任何 Vim 的命令。比如，:echo myvar，该命令会在当前的脚本代码位置和上下文上被执行。 只需要简单使用:debug 1，你就获得了REPL调试特性。 当然，调试模式下是可以定义断点的，不然的话每一行都去单步调试就会十分痛苦。（断点之所以被叫做断点，是因为运行到它们的时候，运行就会停止下来。因此，你可以利用断点跳过自己不感兴趣的代码区域）。请查阅:h :breakadd、 :h :breakdel和 :h :breaklist获取更多细节。 假设你需要知道你每次在保存一个文件的时候有哪些代码在运行： :au BufWritePost \" signify BufWritePost \" * call sy#start() :breakadd func *start :w \" Breakpoint in \"sy#start\" line 1 \" Entering Debug mode. Type \"cont\" to continue. \" function sy#start \" line 1: if g:signify_locked >s \" function sy#start \" line 3: endif > \" function sy#start \" line 5: let sy_path = resolve(expand('%:p')) >q :breakdel * 正如你所见，使用命令会重复之前的调试命令，也就是在该例子中的s命令。 :debug命令可以和verbose选项一起使用。 语法文件调试 语法文件由于包含错误的或者复制的正则表达式，常常会使得 Vim 的运行较慢。如果 Vim 在编译的时候包含了+profile feature特性，就可以给用户提供一个超级好用的:syntime命令。 :syntime on \" 多次敲击来重绘窗口，这样的话就会使得相应的语法规则被重新应用一次 :syntime off :syntime report 输出结果包含了很多的度量维度。比如，你可以通过结果知道哪些正则表达式耗时太久需要被优化；哪些正则表达式一直在别使用但重来没有一次成功匹配。 请查阅:h :syntime。 杂项 附加资源 资源名称 简介 七个高效的文本编辑习惯 作者：Bram Moolenaar（即 Vim 的作者） 七个高效的文本编辑习惯 2.0（PDF 版） 同上 IBM DeveloperWorks: 使用脚本编写 Vim 编辑器 Vim 脚本编写五辑 《漫漫 Vim 路》 使用魔抓定制 Vim 插件 《 Vim 实践 (第 2 版)》 轻取 Vim 最佳书籍 Vimcasts.org Vim 录屏演示 为什么是个脚本都用 vi？ 常见误区释疑 你不爱 vi，所以你不懂 Vim 简明,扼要,准确的干货 Vim 配置集合 目前，网上有很多流行 Vim 配置集合，对于 Vim 配置集合，个人认为有利有弊。 对于维护的比较好的配置，比如 SpaceVim 还是值得尝试的，可以节省很多自行配置的时间。 当然，网上还有很多其他很流行的配置，比如： k-vim amix's vimrc janus 常见问题 编辑小文件时很慢 有两个因素对性能影响非常大： 过于复杂的 正则表达式 。尤其是 Ruby 的语法文件，以前会造成性能下降。（见调试语法文件） 屏幕重绘 。有一些功能会强制重绘所有行。 典型肇事者 原因 解决方案 :set cursorline 会导致所有行重绘 :set nocursorline :set cursorcolumn 会导致所有行重绘 :set nocursorcolumn :set relativenumber 会导致所有行重绘 :set norelativenumber :set foldmethod=syntax 如果语法文件已经很慢了，这只会变得更慢 :set foldmethod=manual，:set foldmethod=marker 或者使用快速折叠插件 :set synmaxcol=3000 由于内部表示法，Vim 处理比较长的行时会有问题。让它高亮到 3000 列…… :set synmaxcol=200 matchparen.vim Vim 默认加载的插件，用正则表达式查找配对的括号 禁用插件：:h matchparen 注意：只有在你真正遇到性能问题的时候才需要做上面的调整。在大多数情况下使用上面提到的选项是完全没有问题的。 编辑大文件的时候很慢 Vim 处理大文件最大的问题就是它会一次性读取整个文件。这么做是由于缓冲区的内部机理导致的（在 vim_dev 中讨论）。 如果只是想查看的话，tail hugefile | vim - 是一个不错的选择。 如果你能接受没有语法高亮，并且禁用所有插件和设置的话，使用： $ vim -u NONE -N 这将会使得跳转变快很多，尤其是省去了基于很耗费资源的正则表达式的语法高亮。你还可以告诉 Vim 不要使用交换文件和 viminfo 文件，以避免由于写这些文件而造成的延时： $ vim -n -u NONE -i NONE -N 简而言之，尽量避免使用 Vim 写过大的文件。 持续粘贴（为什么我每次都要设置 'paste' 模式） 持续粘贴模式让终端模拟器可以区分输入内容与粘贴内容。 你有没有遇到过往 Vim 里粘贴代码之后被搞的一团糟？ 这在你使用 cmd+v、shirt-insert、middle-click 等进行粘贴的时候才会发生。 因为那样的话你只是向终端模拟器扔了一大堆的文本。 Vim 并不知道你刚刚是粘贴的文本，它以为你在飞速的输入。 于是它想缩进这些行但是失败了。 这明显不是个问题，如果你用 Vim 的寄存器粘贴，如：\"+p ，这时 Vim 就知道了你在粘贴，就不会导致格式错乱了。 使用 :set paste 就可以解决这个问题正常进行粘贴。见 :h 'paste' 和 :h 'pastetoggle' 获取更多信息。 如果你受够了每次都要设置 'paste' 的话，看看这个能帮你自动设置的插件：bracketed-paste。 点此查看该作者对于这个插件的更多描述。 Neovim 尝试把这些变得更顺畅，如果终端支持的话，它会自动开启持续粘贴模式，无须再手动进行切换。 在终端中按 ESC 后有延时 如果你经常使用命令行，那么肯定要接触 终端模拟器 ，如 xterm、gnome-terminal、iTerm2 等等（与实际的终端不同）。 终端模拟器与他们的祖辈一样，使用 转义序列 （也叫 控制序列 ）来控制光标移动、改变文本颜色等。转义序列就是以转义字符开头的 ASCII 字符串（用脱字符表示法表示成 ^[ ）。当遇到这样的字符串后，终端模拟器会从终端信息数据库中查找对应的动作。 为了使用问题更加清晰，我会先来解释一下什么是映射超时。在映射存在歧义的时候就会产生映射超时： :nnoremap ,a :echo 'foo' :nnoremap ,ab :echo 'bar' 上面的例子中两个映射都能正常工作，但是当输入 ,a 之后，Vim 会延时 1 秒，因为它要确认用户是否还要输入那个 b。 转义序列会产生同样的问题： 作为返回普通模式或取消某个动作的按键而被大量使用 光标键使用转义序列进行的编码 Vim 期望 Alt （也叫作 Mate Key ）会发送一个正确的 8-bit 编码的高位，但是许多终端模拟器并不支持这个（也可能默认没有启用），而只是发送一个转义序列作为代替。 你可以这样测试上面所提到的事情： vim -u NONE -N 然后输入 i ，你会看到一个以 ^[ 开头的字符串，表明这是一个转义序列，^[ 就是转义字符。 简而言之，Vim 在区分录入的 和转义序列的时候需要一定的时间。 默认情况下，Vim 用 :set timeout timeoutlen=1000，就是说它会用 1 秒的时间来区分有歧义的映射 以及 按键编码。这对于映射来说是一个比较合理的值，但是你可以自行定义按键延时的长短，这是解决该问题最根本的办法： set timeout \" for mappings set timeoutlen=1000 \" default value set ttimeout \" for key codes set ttimeoutlen=10 \" unnoticeable small value 在 :h ttimeout 里你可以找到一个关于这些选项之间关系的小表格。 而如果你在 tmux 中使用 Vim 的话，别忘了把下面的配置加入到你的 ~/.tmux.conf文件中： set -sg escape-time 0 无法重复函数中执行的搜索 在命令中的搜索（/、:substitute 等）内容会改变“上次使用的搜索内容”。（它保存在/寄存器中，用 :echo @/ 可以输出它里面的内容） 简单的文本变化可以通过 . 重做。（它保存在 . 寄存器，用 :echo @. 可以输出它的内容） 而在你在函数中进行这些操作的时候，一切就会变得不同。因此你不能用 N/n 查找某个函数刚刚查找的内容，也不能重做函数中对文本的修改。 帮助文档：:h function-search-undo。 进阶阅读 Vim 插件开发指南 常用插件列表 加入我们 可以协助我们核对翻译，或者从章节列表中认领章节进行翻译。 参考资料 Nifty Little Nvim Techniques to Make My Life Easier -- Series 1 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"初识Vim.html":{"url":"初识Vim.html","title":"Vim初识","keywords":"","body":"初识Vim，想说爱你不容易开始编辑初识Vim，想说爱你不容易 开始编辑 进入编辑模式就可以像其他编辑器一样编辑了 使用i(insert)进入编辑模式，开始输入文字 i表示(insert)出现在光标字符之前，a(append)出现在光标字符之后，o(open a line below)出现在当前行的下面 使用Esc又回到normal模式。使用:wq保存退出 A：表示在行的末尾插入 I：表示在行的开头插入 O：表示在行的上一行插入 w：表示保存 q!：表示强制退出，不保存 wq：表示保存并退出 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vimtutor1.7记录.html":{"url":"vimtutor1.7记录.html","title":"Vim官方中文教程","keywords":"","body":"vimtutor教程简介第一讲第一节：移动光标第一讲第二节：VIM的进入和退出第一讲第三节：文本编辑之删除第一讲第四节：文本编辑之插入第一讲第五节：文本编辑之添加第一讲第六节：编辑文件第一讲小结第二讲第一节：删除类命令第二讲第二节：更多删除类命令第二讲第三节：关于命令和对象第二讲第四节：使用计数指定动作第二讲第五节：使用计数以删除更多第二讲第六节：操作整行第二讲第七节：撤销类命令第二讲小结第三讲第一节：置入类命令第三讲第二节：替换类命令第三讲第三节：更改类命令第三讲第四节：使用c更改更多第三讲小结第四讲第一节：定位及文件状态第四讲第二节：搜索类命令第四讲第三节：配对括号的查找第四讲第四节：替换命令第四讲小结第五讲第一节：在VIM内执行外部命令的方法第五讲第二节：关于保存文件的更多信息第五讲第三节：一个具有选择性的保存命令第五讲第四节：提取和合并文件第五讲小结第六讲第一节：打开类命令第六讲第二节：附加类命令第六讲第三节：另外一个置换类命令的版本第六讲第四节：复制粘贴文本第六讲第五节：设置类命令的选项第六讲小结第七讲第一节：获取帮助信息第七讲第二节：创建启动脚本第七讲第三节：补全功能第七讲小结结语vimtutor 教程简介 第一讲第一节：移动光标 第一讲第二节：VIM的进入和退出 第一讲第三节：文本编辑之删除 第一讲第四节：文本编辑之插入 第一讲第五节：文本编辑之添加 第一讲第六节：编辑文件 第一讲小结 第二讲第一节：删除类命令 第二讲第二节：更多删除类命令 第二讲第三节：关于命令和对象 第二讲第四节：使用计数指定动作 第二讲第五节：使用计数以删除更多 第二讲第六节：操作整行 第二讲第七节：撤销类命令 第二讲小结 第三讲第一节：置入类命令 第三讲第二节：替换类命令 第三讲第三节：更改类命令 第三讲第四节：使用c更改更多 第三讲小结 第四讲第一节：定位及文件状态 第四讲第二节：搜索类命令 第四讲第三节：配对括号的查找 第四讲第四节：替换命令 第四讲小结 第五讲第一节：在VIM内执行外部命令的方法 第五讲第二节：关于保存文件的更多信息 第五讲第三节：一个具有选择性的保存命令 第五讲第四节：提取和合并文件 第五讲小结 第六讲第一节：打开类命令 第六讲第二节：附加类命令 第六讲第三节：另外一个置换类命令的版本 第六讲第四节：复制粘贴文本 第六讲第五节：设置类命令的选项 第六讲小结 第七讲第一节：获取帮助信息 第七讲第二节：创建启动脚本 第七讲第三节：补全功能 第七讲小结 结语 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim默认快捷键.html":{"url":"vim默认快捷键.html","title":"Vim快捷键","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程1.html":{"url":"vim入门教程1.html","title":"Vim入门教程1","keywords":"","body":"一、Vim配置文件.vimrc二、Vim基本配置2.1支持中文不乱码2.2显示行号2.3突出显示当前行2.4 突出显示当前列2.5启用鼠标2.6显示括号匹配2.7设置缩进2.8设置粘贴模式2.9显示空格和tab键2.10显示状态栏和光标当前位置2.11打开文件类型检测强烈建议把caplocks改成esc，大小写用shift，hjkl方向可以改成jikl 一、Vim配置文件.vimrc Vim编辑器相关的所有功能开关都可以通过.vimrc文件进行设置。 二、Vim基本配置 默认情况下，Vim编辑器既不显示行号，也没有语法高亮、智能缩进、为了方便使用，基本的Vim配置选项一般都会包括： 2.1支持中文不乱码 \"设置编码\" set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936 set termencoding=utf-8 set encoding=utf-8 与Vim编码有关的变量包括：encoding、fileencoding、termencoding。 encoding选项用于缓存的文本、寄存器、Vim 脚本文件等；fileencoding选项是Vim写入文件时采用的编码类型；termencoding选项表示输出到终端时采用的编码类型。 2.2显示行号 \"显示行号\" set nu set number 2.3突出显示当前行 \"cursorline的缩写形式\" set cursorline set cul 2.4 突出显示当前列 \"cursorcolumn的缩写形式\" set cursorcolumn set cuc 2.5启用鼠标 Vim编辑器里默认是不启用鼠标的，也就是说不管你鼠标点击哪个位置，光标都不会移动。通过以上设置就可以启动鼠标，不过对于高级玩家来说，用Vim就是为了解放双方不用鼠标，所以这个设置可以根据个人爱好选择。 set mouse=a set selection=exclusive set selectmode=mouse,key 2.6显示括号匹配 set showmatch 2.7设置缩进 \"设置Tab长度为4空格\" set tabstop=4 \"设置自动缩进长度为4空格\" set shiftwidth=4 \"继承前一行的缩进方式，适用于多行注释\" set autoindent 2.8设置粘贴模式 在Vim中通过鼠标右键粘贴时会在行首多出许多缩进和空格，通过set paste可以在插入模式下粘贴内容时不会有任何格式变形、胡乱缩进等问题。 set paste 2.9显示空格和tab键 Vim编辑器中默认不显示文件中的tab和空格符，通过上面的配置可以获得以下的显示效果，方便定位输入错误。 关于Vim特殊字符的显示，推荐阅读Vim怎么显示空格、Tab制表符、行尾换行符等非打印字符。 set listchars=tab:>-,trail:- 2.10显示状态栏和光标当前位置 \"总是显示状态栏\" set laststatus=2 \"显示光标当前位置\" set ruler 2.11打开文件类型检测 filetype plugin indent on 推荐阅读Vim文件类型检测原理及应用。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程2.html":{"url":"vim入门教程2.html","title":"Vim入门教程2","keywords":"","body":"一、Vim的三种操作模式1.1 普通模式 (Normal mode)1.2 插入模式 (Insert mode)1.3 命令行模式 (Command mode)二、Vim文本编辑命令2.1 插入2.2 删除2.3 复制、粘贴2.4 替换2.5 撤销、反撤销2.6 保存2.7 另存为2.8 显示当前文件名一、Vim的三种操作模式 Vim编辑器常用的操作模式一共有 3 种，分别为普通模式(默认)、插入模式、命令行模式。这 3 种模式的转换关系如下图所示。 1.1 普通模式 (Normal mode) Vim 普通模式是 Vim 的默认操作模式，当使用 Vim 命令打开一个文件时，默认进入的就是普通模式。不管用户处于何种模式，只要按下 Esc 键就可回到普通模式。 1.2 插入模式 (Insert mode) 只有在 Vim 插入模式 (也称编辑模式 (input mode))下，才能将键盘键入的内容输入到当前打开的文件中。 在 Vim 普通模式下输入插入命令 i (insert)、附加命令 a (append)、打开命令 o（open）、修改命令 c（change）、取代命令 r 或替换命令 s 等都可以进入插入模式。 1.3 命令行模式 (Command mode) Vim 命令行模式 (也称尾行模式(last line mode)) 主要用于保存文件或退出Vim，同时也可以设置编辑环境和一些编译工作，如列出行号(set nu)、寻找字符串(/target)等。 在 Vim 普通模式下按冒号键 : 即可进入命令行模式下，此时 Vim 会在显示窗口的最后一行显示一个 : 作为 Vim 命令行模式的提示符，等待用户输入命令。 二、Vim文本编辑命令 2.1 插入 在普通模式下按以下按键可进入插入模式，执行插入操作，具体包括： 从光标当前所在位置的【前】一个字符处开始插入：i 从光标当前所在位置的【后】一个字符处开始插入：a 从光标当前所在行的【行首】处开始插入：I 从光标当前所在行的【行尾】处开始插入：A 从光标当前所在行的【下一行】处开始插入：o 从光标当前所在行的【上一行】处开始插入：O 2.2 删除 在普通模式下按以下按键可执行删除操作，具体包括： 删除光标位置的【一个】字符：x 删除当前光标所在【行】：dd 删除从光标所在位置到当前【行首】的内容：d0 删除从光标所在位置到当前【行尾】的内容：d$ 删除从光标所在位置到当前【单词结束】部分的内容并进入插入模式：cw、cW 删除从光标所在位置到当前【单词开始】部分的内容并进入插入模式：cb、cB 删除从光标所在位置到当前【单词结束】部分的内容但不进入插入模式：dw、dW 删除从光标所在位置到当前【单词开始】部分的内容但不进入插入模式：db、dB 注: (1) Vim的命令中，0 表示行首，$ 表示行尾，更多内容可参考Vim教程网上的Vim操作范围、文件范围介绍。 (2) w (word)、b (back)命令用于光标移动，具体可参考vim教程网(https://vimjc.com)上的博客：vim光标移动命令汇总。 (3) cW、cB、dW、dB 命令操作的单词是以空白字符 (空格、Tab) 分隔的字符串。 删除当前【句子】从光标位置开始到【句末】的内容：d) 删除当前【句子】从光标位置开始到【句首】的内容：d( 删除当前【段落】从光标位置开始到【段末】的内容：d} 删除当前【段落】从光标位置开始到【段首】的内容：d{ 注：Vim命令中用 ( 和 ) 表示句子，{ 和 } 表示段落。 2.3 复制、粘贴 在普通模式下按以下按键可执行复制、粘贴操作，具体包括： 复制从光标所在位置到当前【单词结束】部分的内容：yw 复制光标所在【行】的所有字符 (包含换行符)：yy 将最后一次删除或复制操作的文本内容粘贴到光标所在字符之【后】：p小写 将最后一个删除或复制操作的文本内容粘贴到光标当前字符之【前】：P大写 注：yyp 操作可以实现复制一整行内容到当前所在行的下一行。 2.4 替换 在普通模式下按以下按键后，再输入字符可替换原始文件中的内容。 替换光标当前所在字符一次：r 一直替换光标所在字符，直到按下[ESC]键为止：R 删除、复制操作的操作单位可以加操作次数，操作对象的范围为：操作次数 * 操作单位。 例如：d3w 命令表示删除三个单词，10dd 命令表示从光标所在行开始删除后面的十行，更多内容可以参考Vim中的操作符和动作命令。 2.5 撤销、反撤销 在普通模式下可执行撤销操作，具体包括： 撤销最近的一次操作：u 恢复最近的一次操作(取消撤销)： (表示同时按下 Ctrl 键和 r 键) 注：多次执行 u 命令可以连续撤销最近的操作。 2.6 保存 在命令行模式下执行以下命令可保存当前编辑的文件内容 保存当前编辑的文件：:w 保存当前编辑的文件并退出vim：:wq 强制将当前编辑的文件保存：:w! 推荐阅读《Vim 怎么保存文件》获取更多关于使用 Vim 保存文件的方法。 2.7 另存为 在命令行模式下执行命令 :write a.txt 可将 Vim 当前打开的文件另存为新文件 a.txt。 此外，:saveas b.txt (缩写形式 :sav a.txt) 也可将当前打开的文件另存为新文件 a.txt。 2.8 显示当前文件名 Vim 普通模式下，组合命令 可显示当前编辑文件名及行数，可以在不退出 Vim 的情况下了解当前编辑文件的信息，更多内容，可参考30个Vim常用命令和使用技巧。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程3.html":{"url":"vim入门教程3.html","title":"Vim入门教程3","keywords":"","body":"一、Vim光标移动简介二、Vim移动光标命令2.1 上、下、左、右移动2.2 行级移动2.3 文件首尾移动2.4 单词级移动2.5 匹配单词级移动2.6 匹配括号移动2.7 段落级移动2.8 屏幕级移动2.9 翻页三、Vim与其他命令联动一、Vim光标移动简介 Vi/Vim中进行光标移动的命令是针对不同的操作单位而设计，不同的命令对应不同的操作单位。 在执行Vim光标移动命令时，首先要分清楚是采用哪种操作单位：一个字符、一个句子、一个段落、一行、一屏、一页。 确定操作单位后，需要确定命令重复执行的次数。Vim 光标移动命令的操作对象范围计算公式为： 操作范围 = 操作次数 x 操作单位 例如：5h 命令表示左移 5 个字符，8w 命令右移 8 个单词。 二、Vim移动光标命令 2.1 上、下、左、右移动 ^ k j v Vim的上下左右移动光标命令是经过精心设计的，我们在使用编辑器时最常用的操作是下移光标。 而键盘上的 j、k 按键使用最方便，所以分别用来作为下移、上移光标。 h、l 分别位于 j、k 的两侧，根据其所在方位用来实现光标的左移和右移。 2.2 行级移动 0 移动光标到当前行行首 $ 移动光标到当前行行尾 ^ 移动光标到当前行的第一个非空字符 nG 移动光标到当前文件的第n行 :n 移动光标到当前文件的第n行 (同上) 注： (1) Vim 的命令中，0 表示行首，$ 表示行尾。可以回顾下Vim文本编辑命令汇总中提到的删除命令，里面就提到了 0 和 $。 (2) 移动光标到当前文件的第 n 行使用的命令 :n 是在vim命令行模式下执行的，所以输入完 :n 后需要按回车键执行命令。 2.3 文件首尾移动 gg 或 :0 移动光标到当前文件的第一行 GG 或 :$ 移动光标到当前未经的最后一行 2.4 单词级移动 w 或 W 移动到下一单词的开头 b 或 B 移动到上一单词的开头 e 或 E 移动到光标所在单词的末尾 W、B、E命令操作的单词是以空白字符(空格、Tab)分隔的字串。 比如字符串“str1-str2 str3-str4”，对W、B、E命令来说是两个单词，而对w、b、e命令来说则是四个单词。 关于Vim单词和字串，可以参考Vim教程网文章Vim基于单词移动及其Vim单词、字串概念。 2.5 匹配单词级移动 * 移动光标到匹配光标当前所在单词的下一个单词 # 移动光标到匹配光标当前所在单词的上一个单词 2.6 匹配括号移动 % 移动光标到括号左半部分( 包括(、{、[ )对应右半匹配部分( )、}、] ) 2.7 段落级移动 } 移动光标到当前段落的末尾 { 移到光标到当前段落的开头 2.8 屏幕级移动 H 移动光标到屏幕的第一行 M 移动光标到屏幕的中间一行 L 移动光标到屏幕的最后一行 2.9 翻页 Ctrl + f 向前滚动一页 Ctrl + b 向后滚动一页 Ctrl + u 向前滚动半页 Ctrl + d 向后滚动半页 三、Vim与其他命令联动 很多命令都可以和Vim教程网总结的vim光标移动命令连动。 基本命令模式为：。 例如，Vim 命令 0y$ 拆开分别表示：0 移动光标到当前行首；y 复制；$ 当前行尾。所以，命令 0y$ 意味着复制光标当前所在行所有内容。 例如，Vim 命令 ye，表示从当前位置拷贝到当前所在单词的最后一个字符。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程4.html":{"url":"vim入门教程4.html","title":"Vim入门教程4","keywords":"","body":" 使用组合键 (同时按下 Ctrl 键 和 s 键) 来保存文件的习惯在 Vim 编辑器中却会出现大问题：Vim/vi 编辑器中按下 会导致 Vim 假卡死，按其他任何按键和命令都不再有任何反应。 解决方法：按下组合键 可解锁 Vim 卡死。 解决原理：组合键 默认在 Vim 中的效果为锁定屏幕。 可通过Vim的按键映射功能设置 为保存文件功能：即在 Vim 配置文件 ~/.vimrc中添加配置项 map :w 或在 Vim 命令行模式下执行命令 :map :w。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程5.html":{"url":"vim入门教程5.html","title":"Vim入门教程5","keywords":"","body":"vim重复操作命令.(英文句点)vim重复操作命令.(英文句点) Vim 编辑器.命令可以用于重复执行命令 在 Vim 尾行模式下，通过 :h.查看 vim 的帮助手册，可以看到： . Repeat last change, with count replaced with [count]. Also repeat a yank command, when the ‘y’ flag is included in ‘cpoptions’. Does not repeat a command-line command 举例来说，删除一个单词，可以使用命令dw(w是word的缩写，表示一个单词，更多示例可以参考Vim教程网上的Vim文本编辑命令汇总) 接着，我们可以使用命令5.再连续删除5个单词，这就是Vim中.点命令的重复功能。 再考虑以下场景：某个源文件中，有若干行以注释符号//结尾，现在我们要在这些行末添加一些相同的内容 我们可以使用如下方式来实现： 搜索字符串//：/\\/\\/ (/需要使用\\进行转义) 现在，只要按下n键就会跳转到下一个搜索到的目标字符串。 从第一个匹配实例开始添加文本：按下A进入行尾追加模式，在行末添加文本 (假设为 comment) 按[Esc]退出编辑模式，这条命令执行完成了。但是接下来还有多个个地方需要执行相同的操作。这时，我们便可以使用.点命令重复执行上一条命令。 跳转到下一个匹配实例并向行末添加文本 n. 上述介绍的Vim中使用.命令重复执行操作的示例如下图所示，大家可以参考并做练习。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程6.html":{"url":"vim入门教程6.html","title":"Vim入门教程6","keywords":"","body":"一、Vim可视化模式介绍二、Vim可视化模式操作示例介绍Vim可视化模式下的字符选择、行选择和块选择模式，Vim可视化模式移动选中文本两端点位置，Vim同时注释多行和同时删除多行 一、Vim可视化模式介绍 Vi/Vim可视化模式(Visual Mode)下可以选择一块编辑区域，然后对选中的文件内容执行插入、删除、替换、改变大小写等操作，是Vim使用过程中使用非常频繁的一种模式 在Vim命令模式下，输入 v 或者 V 或者 Ctrl + v 都可进入可视化模式，这三个Vim可视化模式的主要区别在于： 字符选择模式: 选中光标经过的所有字符，普通模式下按 v 进入 行选择模式：选中光标经过的所有行，普通模式下按 V 进入 块选择模式：选中一整个矩形框表示的所有文本，普通模式下按 + v 进入 如下图所示，进入Vim可视模式后，鼠标选中的文本区域由两个端点来标识(即左上角和右下角) 默认情况下，在Vim可视化模式下移动鼠标是控制右下角端点的位置，当需要调整左上角端点的位置时，可以使用o键在左上角和右下角之间进行切换 二、Vim可视化模式操作示例 2.1 Vim字符选择 按键 v 进入Vim字符选择可视化模式，通过Vim鼠标移动命令 H 把鼠标往右移动，选择多个字符。 当然，选择好文本后，可以用 y 进行复制，用 p 命令粘贴等。 2.2 Vim同时注释多行 使用Vim可视化模式可以很方便地操作多行文本内容，比如一次性注释多行文本，可以如下操作： (1) Ctrl + v进入块选择模式 (2) 向上或向下移动光标选择多行 (3) 移动光标到行的起始位置 (4) 然后按大写的 I 进入行首插入模式 (5) 插入注释符 (6) 按Esc回到命令模式 需要注意的是：Vim同时编辑多行时，只有在当前的插入动作结束后(按Esc退为命令模式)，之前选中的其它行才会出现同样插入的文本。 2.3 Vim同时删除多行注释 如果想一次性删除多行注释，则可以这样做： (1) Ctrl + v 进入块选择模式 (2) 向上或向下移动光标，选择要删除的注释符号 (3) 按d键删除 关于Vim可视化模式的更多实例，可以参考Vim可视化模式与面向列编辑文本。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程7.html":{"url":"vim入门教程7.html","title":"Vim入门教程7","keywords":"","body":"Vi/Vim手工自行安装配色方案的主要步骤包括： (1) 确认当前用户目录下存在~/.vim/colors目录，没有则新建，安装的Vim配色方案对应.vim文件需放在该目录下 (2) 下载或编辑某个配色方案的.vim文件，保存到~/.vim/colors目录下 (3) 修改Vim配置文件~/.vimrc，增加配置项colorscheme molokai并保存 (假设下载了一个叫molokai的配色方案文件molokai.vim) 注意：配置项中的 molokai 为配色方案文件的文件名，Vim通过该文件名加载对应.vim文件 下面介绍15个著名的Vim配色方案及其下载地址，大家可以根据图片效果按需使用。推荐阅读2017年排名前10的暗黑简约型vim配色方案。 1. acme-colors acme-colors配色方案支持256种颜色，对应.vim文件下载地址为： https://github.com/plan9-for-vimspace/acme-colors/blob/master/colors/acme.vim 2. base16 base16配色方案包含一系列配色，还提供了一些额外的插件供安装，具体使用可参考github上的说明： https://github.com/chriskempson/base16-vim 3. gotham Gotham自称是一个非常dark的配色方案，包含 gotham和gotham256以及一些其他插件配置，github地址为： https://github.com/whatyouhide/vim-gotham 4. gruvbox gruvbox配色方案在github上的评价较高，据说对人眼非常pleasant，Vim教程网就是用的这个配色方案，下面是github地址及配色截图 https://github.com/morhetz/gruvbox 5. janah janah也是一个dark型的配色方案，github地址为： https://github.com/mhinz/vim-janah 6. jellybeans jellybeans在github上也较流行，github地址： https://github.com/nanotech/jellybeans.vim 7. lucius lucius配色方案的github地址：https://github.com/jonathanfilip/vim-lucius 8. molokai molokai配色方案非常出名，知乎上有个问题你认为最好看的 Vim 配色方案是哪款，molokai的呼声非常高 https://github.com/tomasr/molokai 9. oceanic-next oceanic-next是一个neovim配色方案，依赖其他几个插件和配色方案 https://github.com/mhartington/oceanic-next 10. paramount paramount是一个比较简单的Vim配色方案，只关注一些关键配置 https://github.com/owickstrom/vim-colors-paramount 11. flattened flattened也是一个很简介但不简单的配色方案，官方说法是没有废话“without the bullshit” https://github.com/romainl/flattened 12. railscasts railscasts同时支持GUI和终端方式，github地址为： https://github.com/jpo/vim-railscasts-theme 13. seoul256 seoul256是一个低对比度(low-contrast)的配色方案，github地址： https://github.com/junegunn/seoul256.vim 14. solarized solarized配色方案在github上的star非常多，https://github.com/altercation/vim-colors-solarized 15. yowish yowish配色方案同时支持GUI和256色终端，也是一个 dark 主题 https://github.com/kabbamine/yowish.vim © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程8.html":{"url":"vim入门教程8.html","title":"Vim入门教程8","keywords":"","body":"一 Vim插件管理器Pathogen二 Vim插件管理器Vundle一 Vim插件管理器Pathogen 1.1 安装Pathogen pathogen只有一个单独的脚本pathogen.vim，其github下载地址为：https://github.com/tpope/vim-pathogen。 Pathogen下载后直接解压并保存到当前用户的 ~/.vim/autoload目录即可完成安装。 1.2 启用Pathogen 在Vim配置文件vimrc里面增加以下三条命令即可启用Pathogen插件。 execute pathogen#infect() syntax on filetype plugin indent on 1.3 使用Pathogen安装、卸装Vim插件 在当前用户目录~/.vim/下新建bundle目录，将新安装插件放到该目录下后，Pathogen会自动在bundle目录下生成对应插件子目录并使该插件生效。 而如果需要卸载插件，只需把~/.vim/bundle目录下对应的插件目录删除即可。 二 Vim插件管理器Vundle 2.1 安装Vundle Vundle插件也是提供一个Vundle.vim文件，其下载地址为：https://github.com/VundleVim/Vundle.vim.git 将下载的Vundle.vim文件保存到 ~/.vim/bundle 即可完成Vundle的安装。 也可以使用以下的命令直接从 GitHub 拉取 Vundle.vim 文件到 ~/.vim/bundle 文件夹下。 git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 2.2 配置Vundle 修改Vim配置文件vimrc，增加必要的配置，以下是 .vimrc 配置模板。 set nocompatible \"去除VIM一致性，必须\" filetype off \"必须\" \"设置包括vundle和初始化相关的运行时路径\" set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() \"启用vundle管理插件，必须\" Plugin 'VundleVim/Vundle.vim' \"在此增加其他插件，安装的插件需要放在vundle#begin和vundle#end之间\" \"安装github上的插件格式为 Plugin '用户名/插件仓库名'\" call vundle#end() filetype plugin indent on \"加载vim自带和插件相应的语法和文件类型相关脚本，必须\" 更多Vundle有关配置可以参考github上的Quick Start 2.3 使用Vundle安装插件 首先需要将要安装的插件，按照上述配置格式将插件地址填写在vundle#begin和vundle#end之间并保存。 设置好配置文件后，可通过下述两种方法安装插件: (1) 在Vim命令行模式下运行命令:PluginInstall (2) 在终端命令行下通过命令vim +PluginInstall +qall直接安装 至此，需要安装的插件已经安装完毕，可以正常使用了。 2.4 使用Vundle删除插件 (1) 需要删除Vim插件时，只需编辑Vim配置文件.vimrc文件，删除要移除插件所对应的 Plugin 一行； (2) 打开Vim，在Vim命令行模式执行命令:BundleClean即可删除对应Vim插件； 如果你安装的vim插件非常多，又对vim启动速度等非常苛刻，建议你使用另外一款轻量高效的Vim插件管理神器vim-plug。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程9.html":{"url":"vim入门教程9.html","title":"Vim入门教程9","keywords":"","body":"一、Vim基本搜索命令二、Vim高亮搜索三、搜索大小写敏感四、Vim搜索进阶五、Vim正则表达式搜索介绍Vim搜索命令/ 、 ? 、* 和 #，以及Vim正向搜索和反向搜索，Vim正则表达式搜索特定字符和特定行。 一、Vim基本搜索命令 在Vim普通模式下，输入 / 或 ? 符号就进入了搜索模式，/ 用于正向往下搜索，? 用于反向往上搜索。 在搜索模式下可以对Vim打开的整个文本内容进行搜索，当按下 n 时可以继续正向查找下一个相匹配的目前单词。N 的作用与 n 相反，是往上反向搜索目标单词。 在Vim命令模式下，如果要搜索当前光标下的单词，除了可以使用/ 和 ?外，还可以使用特殊命令* 和 #。 假设光标当前所有单词为the，那么在当前光标位置执行命令 * 相当于搜索命令 /\\，命令 # 等同于命令 ?\\。\\ 是一个单词定界符，表示只匹配单词的开头，\\> 也是单词定界符，表示只匹配单词末尾。关于单词定界符的更多内容，可以阅读Vim搜索字符转义与very magic搜索模式。 大家可仔细观看下图的Vim动画教程示意 注意：搜索一些特殊的字符，例如：*、[、]、^、%、/、?、~、$等，需要在它们的前面加上转义符号\\。 二、Vim高亮搜索 为了在Vim中高亮显示被搜索的字符，可以使用命令 set hlsearch，可以在Vim命令行模式执行命令或者在配置文件 .vimrc 中进行永久设置。 如果需要清除最近一次的屏幕搜索高亮结果，可以在Vim命令行模式使用命令 :nohlsearch 或其缩写形式 :noh。更多介绍，可参考文章Vim清除上次的搜索高亮结果-Vim使用技巧(1)。 三、搜索大小写敏感 默认Vim搜索命令是大小写敏感的，因此，搜索 the 不会查找到 The。使用命令 :set ignorecase 会使得Vim搜索变得不区分大小写。 不管 ignorecase 选项的值是什么，都可以在搜索命令中使用 \\c 来强制使得当前搜索模式不区分大小写，而命令 \\C 则会强制当前搜索模式大小写敏感。 因此，/the\\c 既会查找 the，也会查找到 The。 如果打开了 ignorecase 选项，那么你也应该设置 :set smartcase。 当 ignorecase 和 smartcase 选项均打开时，只要你的搜索模式中包含大写字母，那Vim会认为你当前的搜索是区分大小写的，如果搜索模式中不包含任何大写字母，Vim则会认为搜索应该不区分大小写。这是个比较”智能的”推测你搜索意图的机制。 例如，在打开上述两个选项的条件下，/The 只会查找到 The，而 /the 既会查找 the，也会查找到 The等。 注意：smartcase 选项只对你手工输入的搜索模式有效，对于 *、# 或 gd 等是不起作用的。 四、Vim搜索进阶 如果想搜索当前光标所在位置的单词，可以先输入 / 进入搜索模式，然后依次输入命令 来复制光标下的单词并将其插入命令行中。 如果想插入光标下的字串，可以使用命令 。关于Vim单词和字串的概念，可以参考文章Vim单词、字串概念。 完成搜索后，使用 Ctrl-o 会跳转到开始进行搜索的位置，然后使用命令 Ctrl-i 将会往前跳转。 进行过Vim搜索后，当 /、?、:s、:g 命令使用空的搜索模式时会沿用最近一次的搜索模式。所以，在搜索完某个单词后，使用Vim替换命令 :%s//new/g 会将之前搜索的单词全部替换为 new。具体可参考Vim替换命令substitute重用上次的查找模式 在搜索命令前还可以增加一个整数，用于表示搜索目标出现的位置。例如，3/pattern 将会搜索模式 pattern 第三次出现的位置，而 3* 会搜索当前光标所在位置单词第三次出现的位置。 搜索还可以包含一个相对于光标的偏移量，关于搜索偏移量的更多内容，可以参考文章Vim搜索偏移介绍。 五、Vim正则表达式搜索 为了更好的进行搜索，Vim支持正则表达式，最基本的正则表达式规则包括： ^ 表示一行的开头 $ 表示一行的结尾 . 表示任意一个字符 * 匹配0次或n次 5.1 查找在行首的特定字符 上图中用^来匹配行首 5.2 查找在行尾的特定字符 上图中用$来匹配行尾 5.3 匹配特定行(行首匹配) 上图中使用了/^test.*$，其中^表示匹配行首、.*表示匹配任意字符、$表示匹配行尾，合起来表示搜索任意以test开头的行。 关于Vim正则表达式搜索的更多内容，推荐阅读Vim搜索字符转义与very magic搜索模式。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程10.html":{"url":"vim入门教程10.html","title":"Vim入门教程10","keywords":"","body":"一、Vim替换命令语法二、Vim替换命令举例2.1 全局替换并进行确认2.2 将光标所在行出现的所有包含line的字符串中line替换为lines2.3 将从2行到3行中出现的所有包含line的字符串中的line替换为lines2.4 全文的行首加入//字符，批量注释时非常有用2.5 将所有行尾多余的空格删除Vim可以在尾行模式下使用 :substitute 命令将指定的字符替换成其他目标字符，通常使用该命令的缩写格式 :s 进行操作，可基于Vim正则表达式指定操作目标。 一、Vim替换命令语法 Vim替换命令的基本语法是 :[range]s/源字符串/目标字符串/[option]，其中range和option字段都可以缺省不填。 各个字段的意思是： range 表示搜索范围，默认表示当前行 range字段值1,10表示从第1到第10行，%表示整个文件(相当于1,$)，而.,$代表从当前行到文件末尾 s substitute的简写，表示替换 option表示操作类型，默认只对第一个匹配的字符进行替 换 option字段值g(global)表示全局替换，c(comfirm)表示操作时需要确认，i(ignorecase)表示不区分大小写这些选项可以组合使用。 二、Vim替换命令举例 2.1 全局替换并进行确认 执行命令:1,$s/Vim/vim/gc会出现提示”replace with foo(y/n/a/q/l/^E/^Y)?”，询问是否确认执行 待选择操作的含义包括： y 确认执行这个替换 n 取消这个替换 a 执行所有替换且不再询问 q 退出而不做任何改动 l 替换完当前匹配点后退出(last) Ctrl + E 向上翻滚一行 Ctrl + Y 向下翻滚一行 2.2 将光标所在行出现的所有包含line的字符串中line替换为lines :s/line/lines/g表示将光标所在当前行的line全局替换为lines 2.3 将从2行到3行中出现的所有包含line的字符串中的line替换为lines :2,3s/line/lines/g表示将2~3行的line全局替换为lines 2.4 全文的行首加入//字符，批量注释时非常有用 :%s/^/\\/\\//表示在全文范围行首替换插入//，/需要转义 2.5 将所有行尾多余的空格删除 :%s= *$==表示全局替换行尾的一个或多个空格，更多正则表达式的说明可以参考Vim正则表达式搜索 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程11.html":{"url":"vim入门教程11.html","title":"Vim入门教程11","keywords":"","body":"一、单词补全二、行补全三、字典补全在插入模式下，Vim可以不借助任何插件实现自动补全功能。介绍Vim自带的单词自动补全、行自动补全和基于用户自定义字典的自动补全。 一、单词补全 Ctrl + n：当输入完第一个字母后，再按Ctrl + n，Vim会自动出现下拉菜单，且默认选中第一个单词 继续按 Ctrl + n 可以上下选择，但如果缓冲区没有可选单词，那么下拉列表不会有任何选项 Ctrl + p：功能同上，只是默认选中的是列表最后一个单词 二、行补全 在Vim插入模式下输入已经存在行的第一个单词，再按Ctrl + x、Ctrl + l命令，就会列出该整行出来实现Vim行自动补全 三、字典补全 假设有一个备选单词表，文件名为dict.txt，每行一个单词，里面包含以下内容： https://vimjc.com Hello Vim editor best tool 若要实现基于该单词表的Vim自动补齐，需要设置以下步骤： (1) 在~/.vimrc配置文件中加入代码：set dictionary-=~/dict.txt dictionary+=~/dict.txt (2) 打开Vim，在插入模式下输入Ctrl + x后再输入Ctrl + k，就能看到dict.txt文件中定义的单词 (3) 若想直接通过Ctrl + n命令就显示其中的列表，再配置.vimrc文件，加入set complete-=k complete+=k 更多信息可以在Normal模式下查看帮助文档:help dictionary，要使用更加高阶的自动补齐功能，推荐使用Vim youcomplateme插件。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程12.html":{"url":"vim入门教程12.html","title":"Vim入门教程12","keywords":"","body":"一、Vim缓冲区列表二、使用Vim缓冲区列表三、删除Vim缓冲区列表Vim打开文件进行编辑时其实编辑的是文件在内存中的映像(即Vim中的缓冲区) 当使用Vim对缓冲区进行操作时，磁盘文件内容与内存映像不再一致，执行w、x等命令时便是将缓冲区的内容回写到文件 一、Vim缓冲区列表 Vim支持同时在多个缓冲区进行操作，每打开一个文件，Vim就会创建一个对应缓冲区。缓冲区不仅包含了文件的内容，也记录了该文件的编辑状态等配置信息，包括激活、隐藏、上次编辑行数等 假设通过vim命令vim *.txt同时打开了当前目录下的两个文件 1.txt和 2.txt Vim启动时只会显示一个窗口，且窗口内的缓冲区对应着第一个文件，虽然另一个文件当前不可见，但其内容已经被载入到一个Vim的缓冲区 如下图所示，:ls 和 :buffers 命令会列出所有被载入到内存中的缓冲区的列表，%符号指明哪个缓冲区在当前窗口中可见 二、使用Vim缓冲区列表 顾名思义，Vim缓冲区列表是个列表结构 在Vim尾行模式下可通过 :bnext 和 :bprev 命令正向或反向遍历列表，命令Ctrl + ^可以在当前文件和轮换文件间快速切换 而 :bfirst 和 :blast 则分别用于跳转到Vim缓冲区列表的开头和结尾 此外，:ls命令获得的Vim缓冲区列表开头的数字是在缓冲区创建时由Vim自动分配的编号(且无法手动更改)，使用:buffer n命令直接凭编号n跳转到该缓冲区 三、删除Vim缓冲区列表 可以用 :bdelete 命令删除Vim缓冲区 命令格式为:bdelete n1 n2 n3 或 :n,m bdelete，前者用于删除特定缓冲区，后者用于删除一个编号区间段的缓冲区 注意，删除一个缓冲区并不会影响缓冲区所关联的磁盘文件，只是把该文件在内存中的映像删掉 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程13.html":{"url":"vim入门教程13.html","title":"Vim入门教程13","keywords":"","body":"一、使用ctags生成tag标签文件实现跳转二、ctags参数介绍编程语言中的数据类型、结构体、枚举类型、类、对象、类成员、函数、宏等称为标识符 每个标识符的定义、所在文件中的行位置、所在文件的路径等信息称为标签(tag)。 ctags 全称Exuberant Ctags，是一款著名的用于生成代码标签信息，以便在源文件中定位对象的开源工具，目前已支持C、C++、python等40多种编程语言。 ctags最初内置在vim程序汇总，但随着Vim 6.0的发布，ctags已经脱离Vim成为一个独立的项目。 Vim配合ctags 可以实现更加强大的函数跳转、自动补齐等功能。 一、使用ctags生成tag标签文件实现跳转 假设当前项目共包含3个源文件：main.cpp、my_class.cpp、my_class.h 在当前目录下执行命令ctags -R就可以生成当前项目所有源文件对应的tag标签文件 此时，再通过Vim打开当前项目的某个源文件，把光标移动到某个标识符上，通过按键 Ctrl + ] 就可以跳转到对应的定义位置，命令 Ctrl + o 可以回退到原来的位置 如果当前光标下是个局部变量，在Vim命令模式下执行命令 gd 就可以跳转到这个局部变量的定义处 默认情况下，生成的tags文件必须在vim运行的当前目录才能在vim里面正确跳转 可以在Vim尾行模式或Vim配置文件 .~/.vimrc 中通过以下命令显式地指定tag文件路径： :set tags+=tags文件路径 二、ctags参数介绍 ctags 默认并不会提取所有标识符的tag标签，以下命令可以生成更加详细的tag文件 ctags -R --c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v --fields=+liaS --extra=+q 使用命令 ctags --list-kinds=c++ 可列出C++支持生成的标签类型的全量列表(即 –c++-kinds 参数的所有值)： c 类classes) d 宏定义(macro definitions) e 枚举变量(enumerators) f 函数定义(function definitions) g 枚举类型(enumeration names) l 局部变量(local variables)，默认不提取 m 类、结构体、联合体(class, struct, and union members) n 命名空间(namespaces) p 函数原型(function prototypes)，默认不提取 s 结构体类型(structure names) t (typedefs) u 联合体类型(union names) v 变量定义(variable definitions) x 外部变量(external and forward variable declarations)，默认不提取 局部对象、函数声明、外部变量等类型默认不会生成标签，所以在上面的ctags命令中显式加上了这些类型，用于生成所有类型的标签 fields=+iaS 表明ctags要求描述的信息 i 表示如果有继承(inherit)，则生成的tag文件要标识出其父类； a 表示如果元素是类成员则生成的tag文件要标明其访问权限(即public、protected、private) S 表示如果是函数，则生成的tag文件要标识函数的原型(Signature) extra=+q 表示强制要求ctags对同一个语法元素 再 记一行(如果某个语法元素是类的一个成员，ctags默认会给其记录一行)，这样可以保证在Vim中多个同名函数可以通过路径不同来区分 Vim很多插件(如omnicppcomplete、taglist、showfunc)都是依赖于ctags工具生成的tags标签文件来实现除Vim自带补齐功能外更强大的自动补齐、跳转等功能，具体插件的使用方法可参考Vim教程网上的其他教程介绍。 如果你觉得每次手工执行 ctags -R 命令生成tags文件的方式太麻烦，vim8.0以上用户可以使用vim-gutentags插件自动实时生成tags文件。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程14.html":{"url":"vim入门教程14.html","title":"Vim入门教程14","keywords":"","body":"Vim 大部分命令默认只作用于当前行，只有 :write 命令和 :global 命令默认作用于文件所有行 (原创自Vim教程网(https://vimjc.com))。 但很多 Vim 命令都可以加一个行号数字(用于指定某一行)或一对通过 , 或 ; 分割的行号来指明文件范围，扩大命令操作范围。 简单来说，Vim 操作范围的表示方法为：. 表示当前行，$ 表示结束，% 表示所有行，再加上+ 和 -，可灵活表示当前 Vim 打开文件的任意范围。 以删除命令 :d 为例，通过增加 Vim 文件范围，可修改删除命令的操作对象。 Vim命令 操作范围 :d 当前行 :.d 当前行 :1d 第一行 :$d 最后一行 :1,$d 所有行 :%d 所有行 :.,5d 当前行至第 5 行 :,5d 当前行至第 5 行 :,+3d 当前行及接下来的 3 行 :1,+3d 第一行至当前行再加 3 行 :,-3d 当前行及向上的 3 行 :3,'xdelete 第三行至标注 为 x 的那一行 :/^foo/,$delete 当前行以下，以字符 “foo” 开头的那一行至结尾 :/^foo/+1,$delete 当前行以下，以字符 “foo” 开头的那一行的下一行至结尾 除了 , 外，; 也可以分割行号用于表示 Vim 操作范围。 区别在于，a,b 的 b 是以当前行作为参考，而 a;b 的 b 是以 a 行作为参考。 例如，假设当前光标所在为第 5 行，:1,+1d 命令会删除第 1 行至第 6 (5+1) 行，而 :1;+1d 命令则会删除第 1 行和第 2 (1+1) 行。 如果想设置多个寻找条件，只需要在条件前再加上 /，比如： :/foo//bar//quux/d 上面的命令首先在当前行之后寻找第一个包含 “foo” 字符的那一行，然后在找到的 这一行之后 寻找第一个包含 “bar” 字符的那一行，然后再在找到的这一行之后寻找第一个包含 “quux” 的那一行。 最后删除的对象就是最后找到的这一行。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程15.html":{"url":"vim入门教程15.html","title":"Vim入门教程15","keywords":"","body":"Vim支持多种折叠形式：手动折叠manual、基于缩进行折叠indent、基于语法进行折叠syntax、未更改文本折叠diff等 日常编程中用到的Vim折叠形式主要有indent 和 syntax，只需要Vim配置文件 ~/.vimrc中增加以下配置： \"基于缩进进行代码折叠\" set foldmethod=indent \"启动 Vim 时关闭折叠\" set nofoldenable Vim打开文件后，重复使用操作命令 za 可打开或关闭当前折叠；zM 用于关闭所有折叠，zR 则用来打开所有折叠。 Vim折叠代码效果图如下所示： © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程16.html":{"url":"vim入门教程16.html","title":"Vim入门教程16","keywords":"","body":"在Vim插入模式下，通过鼠标右键粘贴内容时会在行首多出许多缩进和空格，导致Vim内粘贴的内容格式错乱。 这是因为鼠标右键粘贴时只是向终端扔了一大堆的文本，Vim 以为你是在快速地输入。 但是当你使用Vim寄存器进行粘贴，如+p 命令时，Vim根据上下文是知道你在粘贴，就不会导致格式错乱。 为了解决Vim鼠标右键粘贴格式乱码问题，可以在Vim尾行模式使用 :set paste。 如果不想每次都输入命令:set paste，可以将命令加入到Vim配置文件~/.vimrc中或使用自动设置插件bracketed-paste。 注：上述Vim视频教程中，使用 :%d 命令表示删除当前文档中的全部内容，可参考《Vim操作范围和文件范围相关概念介绍》一文了解更多细节。 关于bracketed-paste插件的使用方法，Vim教程网后续会进行详细详细的介绍，欢迎关注！ Vim命令autocmd 用于指示 Vim 监听某一类事件，一旦该事件发生，Vim 将执行指定的命令。 InsertLeave 表示 离开插入模式 事件。如Vim粘贴文本格式错乱介绍，paste 选项可避免粘贴文本到Vim中出现格式错乱。但是该选项会使得 autoindent 等选项失效。 所以一般只有在 Vim 插入模式下才会启用 paste 选项，退出插入模式后关闭对应功能。 以下设置可完成上述功能，保证退出 Vim 插入模式后自动关闭 paste 选项。 autocmd InsertLeave * set nopaste © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程17.html":{"url":"vim入门教程17.html","title":"Vim入门教程17","keywords":"","body":"Vim每打开一个文件，就会在内存中创建一个对应缓冲区，Vim文件缓冲区列表介绍介绍了使用Vim标准的文件缓冲区切换命令实现缓冲区管理 本文介绍Vim插件vim-fswitch，用于实现同伴文件 (如test.h和test.cpp)的快速切换 vim-fswitch 插件提供配置文件fswitch.vim，其安装方法可以参考Vim教程网介绍的Vim插件管理器Pathogen和Vundle简介 安装完Vim插件vim-fswitch 后，在Vim配置文件~/.vimrc 中增加以下键盘映射配置 '同伴文件*.cpp 和 *.h 切换' nmap sw :FSHere 假设Vim当前打开的文件为 MyClass.h，在命令行模式下输入命令 ;sw 后，Vim会在新的文件缓冲区中打开 MyClass.cpp文件显示在当前窗口；再次输入命令 ;sw ，便可以切换到原先的窗口，如下图所示 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程18.html":{"url":"vim入门教程18.html","title":"Vim入门教程18","keywords":"","body":"Vim教程网(https://vimjc.com)介绍的《Vim替换命令substitute使用方法》描述过，Vim 命令行下的替换命令基本语法是： :[range]s/源字符串/目标字符串/[option] 将 substitute 命令的查找域 源字符串 留空，意味着 Vim 将会重用上次的查找模式，而所谓上次的查找模式是通过 Vim 的搜索命令进行指定。 即：:[range]s//目标字符串/[option] 表示查找上次所使用过的 源字符串 查找模式进行搜索。 而在Vim搜索命令有介绍，命令 * 可用于正向查找当前光标所在单词。 因此，配合 * 和上述搜索命令的特性，可以快速地实现替换当前光标所在单词为其他字符串。 关于Vim替换命令和查找命令的使用，推荐阅读《正则表达式及在Vim替换命令中的应用》、《Vim中的搜索模式》。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程19.html":{"url":"vim入门教程19.html","title":"Vim入门教程19","keywords":"","body":"一、打开文件时启动分屏二、Vim内部启动分屏三、Vim分屏时切换屏幕四、设置分屏大小五、关闭Vim分屏Vim支持在打开文件时进行屏幕分割，也支持在Vim编辑器内部进行分屏。Vim分屏是指在同一个Vim窗口中同时显示多个文件的内容。 一、打开文件时启动分屏 使用Vim打开文件时，可以通过参数-On 或 -on来启动分屏。 n 代表整数，表示将整个屏幕分成n部分 大写 O 表示进行垂直方向分屏，小写 o 表示水平方向进行分屏 二、Vim内部启动分屏 使用Vim打开文件后，仍然可以在尾行模式通过以下命令进行屏幕分割 2.1 垂直分屏并打开一个新文件 Vim尾行模式下执行命令 :vsplit filename 或缩写形式 :vsp filename 可实现Vim垂直方向分割屏幕，且打开新的文件 filename 注：v 表示单词 vertical，是中文”垂直”的意思 2.2 水平分屏并打开一个新文件 Vim尾行模式下执行命令 :split filename 或缩写形式 :sp filename 可实现在Vim水平方向分割屏幕，且打开新的文件 filename 2.3 垂直分隔当前打开的文件 Vim命令行模式下执行命令 Ctrl+w v 可将当前打开的文件进行垂直分割 上述命令 Ctrl+w v 的意思是：先同时按键 Ctrl 和 w，再按键 v 2.4 水平分隔当前打开的文件 Vim命令行模式下执行命令 Ctrl+w s 可将当前打开的文件进行水平方向分割 上述命令 Ctrl+w s 表示先同时按键 Ctrl 和 w，再按键 s 三、Vim分屏时切换屏幕 在Vim分屏模式下，可以按以下方式切换当前操作的屏幕窗口： 3.1 轮流切换 在Vim命令行模式下，同时按键 Ctrl+w w 可以在当前的分割屏幕中按顺时针方向切换屏幕 3.2 按指定方向切换屏幕 Vim光标移动命令汇总曾介绍，光标键 h, j, k, l 分别用于左、下、上、右 4个方向，因此： 命令 Ctrl+w h 用于把光标移到左边的屏幕中 命令 Ctrl+w l 用于把光标移到右边的屏幕中 命令 Ctrl+w j 用于把光标移到下边的屏幕中 命令 Ctrl+w l 用于把光标移到上边的屏幕中 四、设置分屏大小 命令 Ctrl+w = 表示设置所有的分屏幕都有相同的高度 命令 Ctrl+w + 用于增加当前屏幕的高度 命令 Ctrl+w - 用于减少当前屏幕的高度 五、关闭Vim分屏 命令 Ctrl+w c 用于关闭当前操作的Vim分屏幕 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程20.html":{"url":"vim入门教程20.html","title":"Vim入门教程20","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程21.html":{"url":"vim入门教程21.html","title":"Vim入门教程21","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程22.html":{"url":"vim入门教程22.html","title":"Vim入门教程22","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程23.html":{"url":"vim入门教程23.html","title":"Vim入门教程23","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程24.html":{"url":"vim入门教程24.html","title":"Vim入门教程24","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程25.html":{"url":"vim入门教程25.html","title":"Vim入门教程25","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程26.html":{"url":"vim入门教程26.html","title":"Vim入门教程26","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程27.html":{"url":"vim入门教程27.html","title":"Vim入门教程27","keywords":"","body":"一、KeyCastOW编译方法windows类似keycastr的显示键盘按键的软件KeyCastOW只在github上提供了源代码和vs工程，需要自行编译二进制文件。 Vim教程网提供的vim视频教程在很多时候需要在屏幕实时显示对应操作的按键，windows系统下显示按键的软件推荐使用KeyCastOW，具有和Mac上的软件keycastr相同的功能。 一、KeyCastOW编译方法 KeyCastOW提供了Visual Studio工程，在windows系统上编译KeyCastOW需要先安装vs2013或vs2015。 安装好vs后需要配置Command Prompt (一个配置好了各种环境变量的cmd) 用于快速编译KeyCastOW工程。 Vim教程网介绍使用Visual Studio的“External Tools”功能，把Command Prompt快捷方式放到IDE的“Tools”菜单下。 再使用Command Prompt编译KeyCastOW源码，编译命令为：msbuild /p:platform=win32 /p:Configuration=Release，编译好的二进制文件为Release\\keycastow.exe © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程28.html":{"url":"vim入门教程28.html","title":"Vim入门教程28","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程29.html":{"url":"vim入门教程29.html","title":"Vim入门教程29","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程30.html":{"url":"vim入门教程30.html","title":"Vim入门教程30","keywords":"","body":"一、vim map命令前缀1.1 括号自动补全映射1.2 Backspace的映射二、Vim快捷键与Leader键三、Vim快捷键实例vim快捷键是某种vim命令或命令串的别名，有点类似Vim中的宏。 使用Vim命令 :map 可以将键盘上的某个按键与Vim的命令映射起来，完成Vim快捷键的绑定。例如 :map a b 在map生效的情况下，按下a就等同于按下了b。 一、vim map命令前缀 在map命令前加上前缀可以组合成几种不同的命令，表示在不同的Vim模式下生效。 n 在普通模式 (normal) 下生效 i 在插入模式 (insert) 下生效 v 在可视化模式 (visual) 下生效 c 在命令模式 (command-line) 下生效 o 在命令等待时 (operator pending) 生效，比如输入d之后会等待输入下一个字符，可能是d或者数字 un删除键的映射 nore非递归 (non-recursive)，意思是将a 映射为b，b映射为c，输入a的时候不会被映射为c，而只会映射b 以上前缀可以组合使用，比如 nnoremap，nunmap，vnoremap 等。不带前缀的map命令默认对 normal 模式和 visual 模式生效 Vim :map 默认是递归映射模式。 1.1 括号自动补全映射 \" 在插入模式下非递归映射(为 )i\" inoremap ( ()i inoremap [ []i inoremap { {}i inoremap \" \"\"i 这样输入(, [, {, “的时候都会自动补全，并且把光标移到括号的内部 1.2 Backspace的映射 Backspace的功能是向前删除，而x键是向后删除，在normal模式下z键没有什么作用。所以用z键实现backspace的功能是个不错的选择 nnoremap z il 这样子，normal模式用 z 删除就可以实现Backspace的功能 二、Vim快捷键与Leader键 Vim的 mapleader 变量对所有map映射命令起效，它的作用是将参数 替换成 mapleader 变量的值 如果 mapleader 变量没有设置，则用默认的反斜杠 \\代替，因此Vim映射 :map A oanother line 等效于：:map \\A oanother line 如果设置了 mapleader 变量，例如 :let mapleader = \",\"，那么 :map A oanother line 就等效于： :map ,A oanother line 三、Vim快捷键实例 推荐阅读常用Vim命令及实用Vim按键映射配置详解获取更多实用的Vim按键映射配置和Vim命令说明。 © by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程31.html":{"url":"vim入门教程31.html","title":"Vim入门教程31","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程32.html":{"url":"vim入门教程32.html","title":"Vim入门教程32","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程33.html":{"url":"vim入门教程33.html","title":"Vim入门教程33","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程34.html":{"url":"vim入门教程34.html","title":"Vim入门教程34","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程35.html":{"url":"vim入门教程35.html","title":"Vim入门教程35","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程36.html":{"url":"vim入门教程36.html","title":"Vim入门教程36","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程37.html":{"url":"vim入门教程37.html","title":"Vim入门教程37","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程38.html":{"url":"vim入门教程38.html","title":"Vim入门教程38","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程39.html":{"url":"vim入门教程39.html","title":"Vim入门教程39","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"vim入门教程40.html":{"url":"vim入门教程40.html","title":"Vim入门教程40","keywords":"","body":"© by winnerzr all right reserved，powered by Gitbook该文档修订时间： 2021-02-23 16:40:04 new Valine({el: \"#vcomments\",appId: 'Pmai2zSyIldhmWIcUD2yFIcp-gzGzoHsz',appKey: 'TuPQ3Y38BG6lBdwDvl2cmMmb',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "}}